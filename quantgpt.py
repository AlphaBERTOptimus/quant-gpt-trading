# -*- coding: utf-8 -*-
"""QuantGPT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EdZ5hIzcTkLy7fB3Awrt3oDZ3lP45j88
"""

# =====================================================
# QuantGPT - 完整AI量化金融平台
# 集成功能：AI分析 + 策略回测 + 实时筛选 + 基本面分析 + 行业轮动
# 作者：专业AI量化工程师
# 目标：打造最全面的个人量化投资平台
# =====================================================

import warnings
warnings.filterwarnings('ignore')

import torch
import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import json
import logging
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from transformers import pipeline, AutoTokenizer, AutoModelForSequenceClassification
import threading
import time
import requests

# 扩展的默认股票池
DEFAULT_STOCK_POOL = [
    # 大盘科技股
    "AAPL", "GOOGL", "MSFT", "TSLA", "NVDA", "AMZN", "META", "NFLX",
    # 传统价值股
    "BRK-B", "JPM", "JNJ", "PG", "KO", "PFE", "XOM", "CVX", "WMT", "HD",
    # 金融股
    "BAC", "WFC", "GS", "MS", "AXP",
    # 工业股
    "BA", "CAT", "GE", "MMM", "HON",
    # 医疗股
    "UNH", "ABBV", "MRK", "TMO", "DHR",
    # 消费股
    "DIS", "MCD", "SBUX", "NKE", "COST",
    # 能源股
    "COP", "SLB", "EOG", "PSX",
    # 通信股
    "VZ", "T", "CMCSA"
]

# =====================================================
# 核心配置类
# =====================================================

@dataclass
class QuantGPTConfig:
    """QuantGPT配置类"""
    initial_capital: float = 100000.0
    commission: float = 0.001
    slippage: float = 0.0005
    max_position_size: float = 0.2
    risk_free_rate: float = 0.02

    # AI模型配置
    sentiment_model: str = "ProsusAI/finbert"
    device: str = "cuda" if torch.cuda.is_available() else "cpu"

    # 数据配置
    default_period: str = "2y"
    min_data_points: int = 200

@dataclass
class AdvancedScreeningCriteria:
    """高级股票筛选条件"""

    # 基本面指标
    pe_ratio_min: Optional[float] = None
    pe_ratio_max: Optional[float] = None
    pb_ratio_min: Optional[float] = None
    pb_ratio_max: Optional[float] = None
    roe_min: Optional[float] = None
    roa_min: Optional[float] = None
    debt_to_equity_max: Optional[float] = None
    current_ratio_min: Optional[float] = None
    quick_ratio_min: Optional[float] = None

    # 盈利能力
    gross_margin_min: Optional[float] = None
    operating_margin_min: Optional[float] = None
    net_margin_min: Optional[float] = None

    # 成长性指标
    revenue_growth_min: Optional[float] = None
    earnings_growth_min: Optional[float] = None

    # 股息指标
    dividend_yield_min: Optional[float] = None
    payout_ratio_max: Optional[float] = None

    # 技术指标
    rsi_min: Optional[float] = None
    rsi_max: Optional[float] = None
    macd_signal: Optional[str] = None
    bollinger_position: Optional[str] = None

    # 价格和市值
    price_min: Optional[float] = None
    price_max: Optional[float] = None
    market_cap_min: Optional[float] = None
    market_cap_max: Optional[float] = None

    # 成交量
    volume_min: Optional[int] = None
    avg_volume_ratio_min: Optional[float] = None

    # 移动平均线条件
    above_sma_20: Optional[bool] = None
    above_sma_50: Optional[bool] = None
    sma_trend: Optional[str] = None

    # 涨跌幅条件
    change_percent_min: Optional[float] = None
    change_percent_max: Optional[float] = None

    # AI评分条件
    ai_score_min: Optional[float] = None
    recommendation_filter: Optional[List[str]] = None

    # 行业和板块
    sectors: Optional[List[str]] = None
    exclude_sectors: Optional[List[str]] = None
    industries: Optional[List[str]] = None

    # 地区
    countries: Optional[List[str]] = None
    exclude_countries: Optional[List[str]] = None

# =====================================================
# AI情感分析引擎
# =====================================================

class AIAnalysisEngine:
    """AI驱动的金融分析引擎"""

    def __init__(self, config: QuantGPTConfig):
        self.config = config
        self.setup_models()

    def setup_models(self):
        """初始化AI模型"""
        print("🤖 正在加载AI模型...")

        try:
            self.sentiment_analyzer = pipeline(
                "sentiment-analysis",
                model=self.config.sentiment_model,
                return_all_scores=True,
                device=0 if self.config.device == "cuda" else -1
            )
            print("✅ FinBERT情感分析模型加载成功")

        except Exception as e:
            print(f"⚠️ AI模型加载失败，使用备用方案: {e}")
            self.sentiment_analyzer = None

    def analyze_sentiment(self, text: str) -> Dict:
        """分析金融文本情感"""
        if not self.sentiment_analyzer:
            return {"sentiment": "neutral", "confidence": 0.5, "error": "Model not available"}

        try:
            result = self.sentiment_analyzer(text)
            best_result = max(result[0], key=lambda x: x['score'])

            return {
                "sentiment": best_result['label'],
                "confidence": best_result['score'],
                "text_preview": text[:100] + "..." if len(text) > 100 else text,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            return {"sentiment": "neutral", "confidence": 0.5, "error": str(e)}

    def generate_market_insight(self, symbol: str, price_data: pd.DataFrame,
                              news_sentiment: float = 0.5) -> Dict:
        """生成AI驱动的市场洞察"""

        # 计算技术指标
        current_price = price_data['Close'].iloc[-1]
        prev_price = price_data['Close'].iloc[-2]
        price_change = (current_price - prev_price) / prev_price

        # 计算移动平均
        sma_20 = price_data['Close'].rolling(20).mean().iloc[-1]
        sma_50 = price_data['Close'].rolling(50).mean().iloc[-1]

        # 计算RSI
        delta = price_data['Close'].diff()
        gain = delta.where(delta > 0, 0).rolling(14).mean()
        loss = -delta.where(delta < 0, 0).rolling(14).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        current_rsi = rsi.iloc[-1]

        # AI驱动的建议生成
        sentiment_score = news_sentiment
        technical_score = 0.5

        # 技术面评分
        if current_price > sma_20 > sma_50:
            technical_score += 0.3
        if current_rsi < 30:
            technical_score += 0.2
        elif current_rsi > 70:
            technical_score -= 0.2

        # 综合评分
        combined_score = (sentiment_score * 0.4 + technical_score * 0.6)

        # 生成建议
        if combined_score > 0.7:
            recommendation = "🟢 强烈买入"
            reason = "技术面和基本面都显示强劲上涨信号"
        elif combined_score > 0.6:
            recommendation = "🟡 买入"
            reason = "总体趋势积极，建议逢低买入"
        elif combined_score < 0.3:
            recommendation = "🔴 卖出"
            reason = "多重负面信号，建议减仓"
        elif combined_score < 0.4:
            recommendation = "🟡 观望"
            reason = "信号混合，建议等待更明确的方向"
        else:
            recommendation = "🟡 持有"
            reason = "当前趋势不明确，维持现有仓位"

        return {
            "symbol": symbol,
            "current_price": current_price,
            "price_change_pct": price_change * 100,
            "technical_indicators": {
                "sma_20": sma_20,
                "sma_50": sma_50,
                "rsi": current_rsi
            },
            "ai_scores": {
                "sentiment_score": sentiment_score,
                "technical_score": technical_score,
                "combined_score": combined_score
            },
            "recommendation": recommendation,
            "reasoning": reason,
            "confidence": abs(combined_score - 0.5) * 2,
            "timestamp": datetime.now().isoformat()
        }

# =====================================================
# 数据管理器
# =====================================================

class DataManager:
    """金融数据管理器"""

    def __init__(self, config: QuantGPTConfig):
        self.config = config
        self.cache = {}

    def get_stock_data(self, symbol: str, period: str = None,
                      start: str = None, end: str = None) -> Optional[pd.DataFrame]:
        """获取股票数据"""
        period = period or self.config.default_period
        cache_key = f"{symbol}_{period}_{start}_{end}"

        if cache_key in self.cache:
            return self.cache[cache_key]

        try:
            ticker = yf.Ticker(symbol)

            if start and end:
                start_str = str(start) if not isinstance(start, str) else start
                end_str = str(end) if not isinstance(end, str) else end
                data = ticker.history(start=start_str, end=end_str)
            else:
                period_str = str(period) if not isinstance(period, str) else period
                data = ticker.history(period=period_str)

            if data.empty or len(data) < self.config.min_data_points:
                print(f"⚠️ {symbol} 数据不足 ({len(data)}点 < {self.config.min_data_points}点)")
                return None

            # 数据清洗
            for col in ['Open', 'High', 'Low', 'Close', 'Volume']:
                if col in data.columns:
                    data[col] = pd.to_numeric(data[col], errors='coerce')

            data = data.dropna()

            if len(data) < self.config.min_data_points:
                print(f"⚠️ {symbol} 清洗后数据不足 ({len(data)}点 < {self.config.min_data_points}点)")
                return None

            self.cache[cache_key] = data
            print(f"✅ {symbol} 数据获取成功: {len(data)} 天")
            return data

        except Exception as e:
            print(f"❌ 获取 {symbol} 数据失败: {e}")
            return None

    def get_stock_info(self, symbol: str) -> Dict:
        """获取股票基本信息"""
        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info
            return {
                "name": info.get("longName", symbol),
                "sector": info.get("sector", "Unknown"),
                "industry": info.get("industry", "Unknown"),
                "market_cap": info.get("marketCap", 0),
                "pe_ratio": info.get("trailingPE", 0),
                "dividend_yield": info.get("dividendYield", 0)
            }
        except:
            return {"name": symbol, "sector": "Unknown"}

# =====================================================
# 技术指标计算器
# =====================================================

class TechnicalIndicators:
    """技术指标计算器"""

    @staticmethod
    def calculate_sma(data: pd.Series, window: int) -> pd.Series:
        """简单移动平均"""
        return data.rolling(window=window).mean()

    @staticmethod
    def calculate_ema(data: pd.Series, window: int) -> pd.Series:
        """指数移动平均"""
        return data.ewm(span=window, adjust=False).mean()

    @staticmethod
    def calculate_rsi(data: pd.Series, window: int = 14) -> pd.Series:
        """相对强弱指数"""
        delta = data.diff()
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)

        avg_gain = gain.rolling(window=window).mean()
        avg_loss = loss.rolling(window=window).mean()

        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    @staticmethod
    def calculate_macd(data: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Dict[str, pd.Series]:
        """MACD指标"""
        ema_fast = TechnicalIndicators.calculate_ema(data, fast)
        ema_slow = TechnicalIndicators.calculate_ema(data, slow)

        macd = ema_fast - ema_slow
        signal_line = TechnicalIndicators.calculate_ema(macd, signal)
        histogram = macd - signal_line

        return {
            "macd": macd,
            "signal": signal_line,
            "histogram": histogram
        }

    @staticmethod
    def calculate_bollinger_bands(data: pd.Series, window: int = 20, num_std: float = 2) -> Dict[str, pd.Series]:
        """布林带"""
        sma = TechnicalIndicators.calculate_sma(data, window)
        std = data.rolling(window=window).std()

        upper_band = sma + (std * num_std)
        lower_band = sma - (std * num_std)

        return {
            "upper": upper_band,
            "middle": sma,
            "lower": lower_band
        }

    @staticmethod
    def add_all_indicators(df: pd.DataFrame) -> pd.DataFrame:
        """为数据添加所有技术指标"""
        df = df.copy()
        close = df['Close']

        # 移动平均
        df['SMA_20'] = TechnicalIndicators.calculate_sma(close, 20)
        df['SMA_50'] = TechnicalIndicators.calculate_sma(close, 50)
        df['SMA_200'] = TechnicalIndicators.calculate_sma(close, 200)

        df['EMA_12'] = TechnicalIndicators.calculate_ema(close, 12)
        df['EMA_26'] = TechnicalIndicators.calculate_ema(close, 26)

        # RSI
        df['RSI'] = TechnicalIndicators.calculate_rsi(close)

        # MACD
        macd_data = TechnicalIndicators.calculate_macd(close)
        df['MACD'] = macd_data['macd']
        df['MACD_Signal'] = macd_data['signal']
        df['MACD_Histogram'] = macd_data['histogram']

        # 布林带
        bb_data = TechnicalIndicators.calculate_bollinger_bands(close)
        df['BB_Upper'] = bb_data['upper']
        df['BB_Middle'] = bb_data['middle']
        df['BB_Lower'] = bb_data['lower']

        # 成交量指标
        df['Volume_SMA'] = TechnicalIndicators.calculate_sma(df['Volume'], 20)

        return df

# =====================================================
# 交易策略引擎
# =====================================================

class StrategyEngine:
    """交易策略引擎"""

    def __init__(self, config: QuantGPTConfig):
        self.config = config

    def sma_crossover_strategy(self, data: pd.DataFrame, short_window: int = 20,
                              long_window: int = 50) -> pd.DataFrame:
        """移动平均交叉策略"""
        df = data.copy()
        df = TechnicalIndicators.add_all_indicators(df)

        # 生成信号
        df['Signal'] = 0
        df['Signal'][short_window:] = np.where(
            df[f'SMA_{short_window}'][short_window:] > df[f'SMA_{long_window}'][short_window:], 1, 0
        )
        df['Position'] = df['Signal'].diff()

        return df

    def rsi_strategy(self, data: pd.DataFrame, rsi_oversold: int = 30,
                    rsi_overbought: int = 70) -> pd.DataFrame:
        """RSI策略"""
        df = data.copy()
        df = TechnicalIndicators.add_all_indicators(df)

        # 生成信号
        df['Signal'] = 0
        df.loc[df['RSI'] < rsi_oversold, 'Signal'] = 1
        df.loc[df['RSI'] > rsi_overbought, 'Signal'] = -1
        df['Position'] = df['Signal'].diff()

        return df

    def bollinger_bands_strategy(self, data: pd.DataFrame) -> pd.DataFrame:
        """布林带均值回归策略"""
        df = data.copy()
        df = TechnicalIndicators.add_all_indicators(df)

        # 生成信号
        df['Signal'] = 0
        df.loc[df['Close'] < df['BB_Lower'], 'Signal'] = 1
        df.loc[df['Close'] > df['BB_Upper'], 'Signal'] = -1
        df['Position'] = df['Signal'].diff()

        return df

    def ai_sentiment_strategy(self, data: pd.DataFrame, ai_engine: AIAnalysisEngine,
                             sentiment_threshold: float = 0.6) -> pd.DataFrame:
        """AI情感驱动策略"""
        df = data.copy()
        df = TechnicalIndicators.add_all_indicators(df)

        # 模拟每日新闻情感
        np.random.seed(42)
        df['Sentiment_Score'] = np.random.uniform(0.3, 0.7, len(df))

        # 生成信号
        df['Signal'] = 0

        buy_condition = (
            (df['Sentiment_Score'] > sentiment_threshold) &
            (df['RSI'] < 50) &
            (df['Close'] > df['SMA_20'])
        )
        df.loc[buy_condition, 'Signal'] = 1

        sell_condition = (
            (df['Sentiment_Score'] < (1 - sentiment_threshold)) &
            (df['RSI'] > 50)
        )
        df.loc[sell_condition, 'Signal'] = -1

        df['Position'] = df['Signal'].diff()

        return df

# =====================================================
# 回测引擎
# =====================================================

class BacktestEngine:
    """专业级回测引擎"""

    def __init__(self, config: QuantGPTConfig):
        self.config = config
        self.reset()

    def reset(self):
        """重置回测状态"""
        self.capital = self.config.initial_capital
        self.positions = 0
        self.trades = []
        self.portfolio_history = []

    def execute_backtest(self, strategy_data: pd.DataFrame, symbol: str) -> Dict:
        """执行回测"""
        self.reset()

        portfolio_values = []
        cash_history = []
        position_history = []

        for i, (date, row) in enumerate(strategy_data.iterrows()):
            current_price = row['Close']
            position_change = row.get('Position', 0)

            # 修复数据类型
            if isinstance(position_change, pd.Series):
                position_change = position_change.iloc[0] if not position_change.empty else 0
            elif not isinstance(position_change, (int, float)):
                position_change = 0

            try:
                position_change = int(position_change)
            except:
                position_change = 0

            # 执行交易
            if position_change == 1 and self.positions == 0:  # 买入信号
                shares_to_buy = int((self.capital * self.config.max_position_size) /
                                  (current_price * (1 + self.config.commission + self.config.slippage)))
                if shares_to_buy > 0:
                    cost = shares_to_buy * current_price * (1 + self.config.commission + self.config.slippage)
                    if cost <= self.capital:
                        self.capital -= cost
                        self.positions = shares_to_buy

                        self.trades.append({
                            'date': date,
                            'action': 'BUY',
                            'shares': shares_to_buy,
                            'price': current_price,
                            'value': cost
                        })

            elif position_change == -1 and self.positions > 0:  # 卖出信号
                revenue = self.positions * current_price * (1 - self.config.commission - self.config.slippage)
                self.capital += revenue

                self.trades.append({
                    'date': date,
                    'action': 'SELL',
                    'shares': self.positions,
                    'price': current_price,
                    'value': revenue
                })

                self.positions = 0

            # 计算当前组合价值
            portfolio_value = self.capital + self.positions * current_price
            portfolio_values.append(portfolio_value)
            cash_history.append(self.capital)
            position_history.append(self.positions)

        # 添加历史数据到DataFrame
        strategy_data = strategy_data.copy()
        strategy_data['Portfolio_Value'] = portfolio_values
        strategy_data['Cash'] = cash_history
        strategy_data['Positions'] = position_history

        # 计算绩效指标
        metrics = self.calculate_performance_metrics(strategy_data, symbol)

        return {
            'data': strategy_data,
            'trades': self.trades,
            'metrics': metrics,
            'final_value': portfolio_values[-1] if portfolio_values else self.config.initial_capital
        }

    def calculate_performance_metrics(self, data: pd.DataFrame, symbol: str) -> Dict:
        """计算详细的绩效指标"""
        if 'Portfolio_Value' not in data.columns or data['Portfolio_Value'].empty:
            return {}

        portfolio_values = data['Portfolio_Value']
        returns = portfolio_values.pct_change().dropna()

        # 基础指标
        total_return = (portfolio_values.iloc[-1] - self.config.initial_capital) / self.config.initial_capital
        trading_days = len(data)
        annual_return = (1 + total_return) ** (252 / trading_days) - 1

        # 风险指标
        annual_volatility = returns.std() * np.sqrt(252) if len(returns) > 1 else 0

        # 夏普比率
        excess_returns = returns - self.config.risk_free_rate / 252
        sharpe_ratio = (excess_returns.mean() / excess_returns.std() * np.sqrt(252)) if excess_returns.std() != 0 else 0

        # 最大回撤
        cumulative_returns = (1 + returns).cumprod()
        rolling_max = cumulative_returns.expanding().max()
        drawdowns = (cumulative_returns - rolling_max) / rolling_max
        max_drawdown = drawdowns.min()

        # 交易统计
        total_trades = len(self.trades) // 2 if len(self.trades) > 1 else 0

        # 计算胜率
        winning_trades = 0
        if total_trades > 0:
            for i in range(0, len(self.trades) - 1, 2):
                if i + 1 < len(self.trades):
                    buy_price = self.trades[i]['price']
                    sell_price = self.trades[i + 1]['price']
                    if sell_price > buy_price:
                        winning_trades += 1

        win_rate = winning_trades / total_trades if total_trades > 0 else 0

        # 基准比较
        benchmark_return = (data['Close'].iloc[-1] - data['Close'].iloc[0]) / data['Close'].iloc[0]
        alpha = annual_return - benchmark_return

        return {
            'symbol': symbol,
            'total_return': total_return,
            'annual_return': annual_return,
            'benchmark_return': benchmark_return,
            'alpha': alpha,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'total_trades': total_trades,
            'final_value': portfolio_values.iloc[-1],
            'days_traded': trading_days
        }

# =====================================================
# 基本面分析引擎
# =====================================================

class FundamentalAnalysisEngine:
    """基本面分析引擎"""

    def __init__(self):
        self.cache = {}
        self.cache_timeout = 3600

    def get_fundamental_data(self, symbol: str) -> Dict:
        """获取股票基本面数据"""
        cache_key = f"fundamental_{symbol}_{datetime.now().hour}"

        if cache_key in self.cache:
            return self.cache[cache_key]

        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info

            fundamental_data = {
                "symbol": symbol,
                "company_name": info.get("longName", symbol),

                # 估值指标
                "pe_ratio": info.get("trailingPE", None),
                "forward_pe": info.get("forwardPE", None),
                "pb_ratio": info.get("priceToBook", None),
                "ps_ratio": info.get("priceToSalesTrailing12Months", None),
                "peg_ratio": info.get("pegRatio", None),

                # 盈利能力
                "roe": info.get("returnOnEquity", None),
                "roa": info.get("returnOnAssets", None),
                "gross_margin": info.get("grossMargins", None),
                "operating_margin": info.get("operatingMargins", None),
                "net_margin": info.get("profitMargins", None),

                # 财务健康
                "debt_to_equity": info.get("debtToEquity", None),
                "current_ratio": info.get("currentRatio", None),
                "quick_ratio": info.get("quickRatio", None),
                "cash_per_share": info.get("totalCashPerShare", None),

                # 成长性
                "revenue_growth": info.get("revenueGrowth", None),
                "earnings_growth": info.get("earningsGrowth", None),

                # 股息
                "dividend_yield": info.get("dividendYield", None),
                "payout_ratio": info.get("payoutRatio", None),
                "dividend_rate": info.get("dividendRate", None),

                # 市场数据
                "market_cap": info.get("marketCap", None),
                "enterprise_value": info.get("enterpriseValue", None),
                "shares_outstanding": info.get("sharesOutstanding", None),

                # 行业信息
                "sector": info.get("sector", "Unknown"),
                "industry": info.get("industry", "Unknown"),
                "country": info.get("country", "Unknown"),

                # 分析师预期
                "target_price": info.get("targetMeanPrice", None),
                "recommendation": info.get("recommendationMean", None),

                "last_updated": datetime.now().isoformat()
            }

            # 计算派生指标
            fundamental_data.update(self._calculate_derived_metrics(fundamental_data, info))

            # 缓存数据
            self.cache[cache_key] = fundamental_data

            return fundamental_data

        except Exception as e:
            print(f"❌ 获取 {symbol} 基本面数据失败: {e}")
            return {"symbol": symbol, "error": str(e)}

    def _calculate_derived_metrics(self, data: Dict, info: Dict) -> Dict:
        """计算派生的基本面指标"""
        derived = {}

        try:
            # 计算股票评级 (1-100分)
            score = 50

            # PE估值评分
            pe = data.get("pe_ratio")
            if pe and 0 < pe < 15:
                score += 15
            elif pe and 15 <= pe <= 25:
                score += 10
            elif pe and pe > 30:
                score -= 10

            # ROE评分
            roe = data.get("roe")
            if roe and roe > 0.2:
                score += 15
            elif roe and roe > 0.15:
                score += 10
            elif roe and roe < 0.1:
                score -= 5

            # 债务评分
            debt_eq = data.get("debt_to_equity")
            if debt_eq is not None:
                if debt_eq < 0.3:
                    score += 10
                elif debt_eq > 1.0:
                    score -= 10

            # 成长性评分
            rev_growth = data.get("revenue_growth")
            if rev_growth and rev_growth > 0.15:
                score += 10
            elif rev_growth and rev_growth > 0.05:
                score += 5
            elif rev_growth and rev_growth < 0:
                score -= 10

            derived["fundamental_score"] = max(0, min(100, score))

            # 投资风格分类
            pe = data.get("pe_ratio", 0)
            pb = data.get("pb_ratio", 0)
            growth = data.get("revenue_growth", 0)

            if pe and pb and pe < 15 and pb < 2:
                derived["investment_style"] = "Deep Value"
            elif pe and pb and pe < 20 and pb < 3:
                derived["investment_style"] = "Value"
            elif growth and growth > 0.2:
                derived["investment_style"] = "Growth"
            elif growth and growth > 0.1:
                derived["investment_style"] = "GARP"
            else:
                derived["investment_style"] = "Balanced"

            # 质量评级
            roe = data.get("roe", 0)
            debt_eq = data.get("debt_to_equity", float('inf'))
            current_ratio = data.get("current_ratio", 0)

            quality_score = 0
            if roe and roe > 0.15: quality_score += 1
            if debt_eq and debt_eq < 0.5: quality_score += 1
            if current_ratio and current_ratio > 1.5: quality_score += 1

            quality_map = {0: "Poor", 1: "Fair", 2: "Good", 3: "Excellent"}
            derived["quality_rating"] = quality_map.get(quality_score, "Unknown")

        except Exception as e:
            print(f"计算派生指标错误: {e}")

        return derived

# =====================================================
# 股票筛选预设
# =====================================================

class ScreeningPresets:
    """完整的筛选预设"""

    @staticmethod
    def value_stocks() -> AdvancedScreeningCriteria:
        """价值股筛选条件"""
        return AdvancedScreeningCriteria(
            pe_ratio_max=20,          # 放宽到PE < 20
            pb_ratio_max=3,           # 放宽到PB < 3
            debt_to_equity_max=1.0,   # 放宽债务比
            roe_min=8,                # 降低ROE要求
            dividend_yield_min=1,     # 降低股息要求
            market_cap_min=5          # 降低市值要求
        )

    @staticmethod
    def relaxed_value_stocks() -> AdvancedScreeningCriteria:
        """更宽松的价值股条件"""
        return AdvancedScreeningCriteria(
            pe_ratio_max=25,
            pb_ratio_max=4,
            debt_to_equity_max=1.5,
            roe_min=5,
            market_cap_min=1
        )

    @staticmethod
    def growth_stocks() -> AdvancedScreeningCriteria:
        """成长股筛选条件"""
        return AdvancedScreeningCriteria(
            revenue_growth_min=15,
            earnings_growth_min=15,
            roe_min=15,
            gross_margin_min=40,
            debt_to_equity_max=0.3,
            pe_ratio_max=40
        )

    @staticmethod
    def dividend_stocks() -> AdvancedScreeningCriteria:
        """分红股筛选条件"""
        return AdvancedScreeningCriteria(
            dividend_yield_min=3,
            payout_ratio_max=70,
            debt_to_equity_max=0.6,
            current_ratio_min=1.5,
            roe_min=12
        )

    @staticmethod
    def quality_stocks() -> AdvancedScreeningCriteria:
        """优质股筛选条件"""
        return AdvancedScreeningCriteria(
            roe_min=20,
            roa_min=10,
            debt_to_equity_max=0.3,
            current_ratio_min=2,
            gross_margin_min=50,
            operating_margin_min=20,
            net_margin_min=15
        )

    @staticmethod
    def technical_momentum() -> AdvancedScreeningCriteria:
        """技术动量筛选条件"""
        return AdvancedScreeningCriteria(
            rsi_min=50,
            rsi_max=80,
            above_sma_20=True,
            above_sma_50=True,
            ai_score_min=60,
            avg_volume_ratio_min=1.2
        )

# =====================================================
# 主应用类 (完整版)
# =====================================================

class QuantGPT:
    """QuantGPT主应用类 - 完整版"""

    def __init__(self, config: QuantGPTConfig = None):
        self.config = config or QuantGPTConfig()
        self.ai_engine = AIAnalysisEngine(self.config)
        self.data_manager = DataManager(self.config)
        self.strategy_engine = StrategyEngine(self.config)
        self.backtest_engine = BacktestEngine(self.config)
        self.fundamental_engine = FundamentalAnalysisEngine()

        print("🚀 QuantGPT完整系统初始化完成！")
        print(f"💰 初始资金: ${self.config.initial_capital:,.2f}")
        print(f"🤖 AI模型: {self.config.sentiment_model}")
        print(f"⚡ 设备: {self.config.device}")
        print("\n🎯 系统功能:")
        print("  ✅ AI情感分析与智能建议")
        print("  ✅ 多策略回测与绩效分析")
        print("  ✅ 基本面深度分析")
        print("  ✅ 技术指标分析")
        print("  ✅ 投资组合管理")

    def analyze_stock(self, symbol: str, period: str = "1y") -> Dict:
        """分析单只股票 - 增强版"""
        print(f"📊 正在分析 {symbol}...")

        # 获取数据
        data = self.data_manager.get_stock_data(symbol, period)
        if data is None:
            return {"error": f"无法获取{symbol}数据"}

        # 获取股票信息
        stock_info = self.data_manager.get_stock_info(symbol)

        # AI分析
        insight = self.ai_engine.generate_market_insight(symbol, data)

        # 基本面分析
        fundamental_data = self.fundamental_engine.get_fundamental_data(symbol)

        return {
            "symbol": symbol,
            "stock_info": stock_info,
            "data": data,
            "ai_insight": insight,
            "fundamental_analysis": fundamental_data,
            "analysis_date": datetime.now().isoformat()
        }

    def run_strategy_backtest(self, symbol: str, strategy_name: str,
                             period: str = "2y", **strategy_params) -> Dict:
        """运行策略回测"""
        print(f"🔬 正在回测 {symbol} - {strategy_name}...")

        # 获取数据
        data = self.data_manager.get_stock_data(symbol, period)
        if data is None:
            return {"error": f"无法获取{symbol}数据"}

        # 选择策略
        if strategy_name == "sma_crossover":
            strategy_data = self.strategy_engine.sma_crossover_strategy(data, **strategy_params)
        elif strategy_name == "rsi":
            strategy_data = self.strategy_engine.rsi_strategy(data, **strategy_params)
        elif strategy_name == "bollinger_bands":
            strategy_data = self.strategy_engine.bollinger_bands_strategy(data, **strategy_params)
        elif strategy_name == "ai_sentiment":
            strategy_data = self.strategy_engine.ai_sentiment_strategy(data, self.ai_engine, **strategy_params)
        else:
            return {"error": f"未知策略: {strategy_name}"}

        # 执行回测
        backtest_result = self.backtest_engine.execute_backtest(strategy_data, symbol)
        backtest_result['strategy_name'] = strategy_name
        backtest_result['strategy_params'] = strategy_params

        return backtest_result

    def compare_strategies(self, symbol: str, strategies: List[str],
                          period: str = "2y") -> Dict:
        """比较多个策略"""
        print(f"📈 正在比较 {symbol} 的 {len(strategies)} 个策略...")

        results = {}
        for strategy in strategies:
            result = self.run_strategy_backtest(symbol, strategy, period)
            if "error" not in result:
                results[strategy] = result

        if not results:
            return {"error": "所有策略都失败了"}

        return {
            "symbol": symbol,
            "strategies": results,
            "best_strategy": max(results.keys(),
                               key=lambda x: results[x]['metrics'].get('sharpe_ratio', 0))
        }

    def screen_stocks_basic(self, criteria: AdvancedScreeningCriteria, symbols: List[str] = None) -> List[Dict]:
        """改进的股票筛选功能"""
        if symbols is None:
            symbols = DEFAULT_STOCK_POOL

        results = []
        total_processed = 0
        successful_analyses = 0

        print(f"🔍 开始筛选 {len(symbols)} 只股票...")

        for i, symbol in enumerate(symbols, 1):
            try:
                print(f"处理进度: {i}/{len(symbols)} - {symbol}")
                total_processed += 1

                # 获取基本面数据
                fundamental = self.fundamental_engine.get_fundamental_data(symbol)
                if "error" in fundamental:
                    print(f"⚠️ {symbol}: 基本面数据获取失败")
                    continue

                # 添加调试信息
                pe = fundamental.get("pe_ratio")
                roe = fundamental.get("roe")
                print(f"   {symbol}: PE={pe}, ROE={roe}")

                # 检查筛选条件 - 改进版本
                if self._meets_criteria_improved(fundamental, criteria, symbol):
                    successful_analyses += 1

                    # 简化AI分析（避免额外失败点）
                    try:
                        data = self.data_manager.get_stock_data(symbol, "3mo")
                        if data is not None:
                            insight = self.ai_engine.generate_market_insight(symbol, data)
                            ai_recommendation = insight["recommendation"]
                            ai_confidence = insight["confidence"]
                        else:
                            ai_recommendation = "数据不足"
                            ai_confidence = 0
                    except:
                        ai_recommendation = "分析失败"
                        ai_confidence = 0

                    results.append({
                        "symbol": symbol,
                        "fundamental_score": fundamental.get("fundamental_score", 0),
                        "ai_recommendation": ai_recommendation,
                        "ai_confidence": ai_confidence,
                        "pe_ratio": pe,
                        "roe": roe,
                        "sector": fundamental.get("sector", "Unknown"),
                        "investment_style": fundamental.get("investment_style", "Unknown"),
                        "quality_rating": fundamental.get("quality_rating", "Unknown")
                    })
                    print(f"✅ {symbol}: 符合条件")
                else:
                    print(f"❌ {symbol}: 不符合筛选条件")

            except Exception as e:
                print(f"❌ 处理{symbol}时出错: {e}")
                continue

        print(f"\n📊 筛选完成:")
        print(f"   总处理: {total_processed}")
        print(f"   成功分析: {successful_analyses}")
        print(f"   符合条件: {len(results)}")

        # 按基本面评分排序
        results.sort(key=lambda x: x.get("fundamental_score", 0), reverse=True)
        return results

    def _meets_criteria_improved(self, data: Dict, criteria: AdvancedScreeningCriteria,
                                symbol: str = "") -> bool:
        """改进的筛选条件检查"""
        debug_info = []

        # PE比率筛选
        pe = data.get("pe_ratio")
        if criteria.pe_ratio_min:
            if not pe or pe < criteria.pe_ratio_min:
                debug_info.append(f"PE过低: {pe} < {criteria.pe_ratio_min}")
                return False
        if criteria.pe_ratio_max:
            if not pe or pe > criteria.pe_ratio_max:
                debug_info.append(f"PE过高: {pe} > {criteria.pe_ratio_max}")
                return False

        # ROE筛选 - 修复单位问题
        roe = data.get("roe")
        if criteria.roe_min:
            if not roe:
                debug_info.append("ROE数据缺失")
                return False

            # 处理ROE的不同格式（百分比 vs 小数）
            roe_value = roe
            if roe_value < 1:  # 如果是小数形式，转换为百分比
                roe_value = roe_value * 100

            if roe_value < criteria.roe_min:
                debug_info.append(f"ROE过低: {roe_value:.1f}% < {criteria.roe_min}%")
                return False

        # 债务股权比筛选
        debt_eq = data.get("debt_to_equity")
        if criteria.debt_to_equity_max:
            if debt_eq and debt_eq > criteria.debt_to_equity_max:
                debug_info.append(f"债务比过高: {debt_eq} > {criteria.debt_to_equity_max}")
                return False

        # 股息率筛选 - 修复单位问题
        dividend_yield = data.get("dividend_yield")
        if criteria.dividend_yield_min:
            if not dividend_yield:
                debug_info.append("股息率数据缺失")
                return False

            # 处理股息率的不同格式
            dividend_value = dividend_yield
            if dividend_value < 1:  # 如果是小数形式，转换为百分比
                dividend_value = dividend_value * 100

            if dividend_value < criteria.dividend_yield_min:
                debug_info.append(f"股息率过低: {dividend_value:.1f}% < {criteria.dividend_yield_min}%")
                return False

        # 市值筛选
        market_cap = data.get("market_cap")
        if criteria.market_cap_min:
            if not market_cap or market_cap < criteria.market_cap_min * 1e9:  # 转换为实际数值
                debug_info.append(f"市值过低")
                return False

        if debug_info:
            print(f"   {symbol} 筛选失败: {'; '.join(debug_info)}")

        return True

    def get_fundamental_data(self, symbol: str) -> Dict:
        """获取基本面数据"""
        return self.fundamental_engine.get_fundamental_data(symbol)

# =====================================================
# 便捷函数
# =====================================================

def quick_start():
    """快速启动QuantGPT"""
    print("🚀 QuantGPT快速启动...")

    quantgpt = QuantGPT()

    print("\n📊 快速演示 - AAPL分析...")
    apple_result = quantgpt.analyze_stock("AAPL")

    if "error" not in apple_result:
        insight = apple_result["ai_insight"]
        print(f"✅ AAPL AI建议: {insight['recommendation']}")
        print(f"📝 理由: {insight['reasoning']}")

        if "fundamental_analysis" in apple_result and "error" not in apple_result["fundamental_analysis"]:
            fund = apple_result["fundamental_analysis"]
            print(f"💎 基本面评分: {fund.get('fundamental_score', 0):.1f}/100")

    print("\n🔬 快速演示 - 策略回测...")
    backtest_result = quantgpt.run_strategy_backtest("AAPL", "sma_crossover")

    if "error" not in backtest_result:
        metrics = backtest_result["metrics"]
        print(f"✅ 回测完成!")
        print(f"📈 总收益率: {metrics.get('total_return', 0):.2%}")
        print(f"📊 夏普比率: {metrics.get('sharpe_ratio', 0):.3f}")

    print("\n🔍 快速演示 - 价值股筛选...")
    screening_result = quantgpt.screen_stocks_basic(ScreeningPresets.value_stocks())

    if screening_result:
        print(f"✅ 找到 {len(screening_result)} 只价值股:")
        for stock in screening_result[:3]:
            print(f"   {stock['symbol']}: {stock['fundamental_score']:.1f}分")

    print("\n🎉 QuantGPT已准备就绪!")
    return quantgpt

def quick_analyze(symbol: str, quantgpt=None):
    """快速分析单只股票"""
    if quantgpt is None:
        quantgpt = QuantGPT()

    print(f"🔍 快速分析 {symbol}...")
    result = quantgpt.analyze_stock(symbol)

    if "error" not in result:
        insight = result["ai_insight"]
        print(f"✅ {symbol}:")
        print(f"   价格: ${insight['current_price']:.2f}")
        print(f"   建议: {insight['recommendation']}")
        print(f"   置信度: {insight['confidence']:.1%}")

        if "fundamental_analysis" in result and "error" not in result["fundamental_analysis"]:
            fund = result["fundamental_analysis"]
            print(f"   基本面评分: {fund.get('fundamental_score', 0):.1f}/100")
    else:
        print(f"❌ {result['error']}")

    return result

def quick_screen(screen_type: str = "value", quantgpt=None):
    """快速筛选股票"""
    if quantgpt is None:
        quantgpt = QuantGPT()

    preset_map = {
        "value": ScreeningPresets.value_stocks(),
        "growth": ScreeningPresets.growth_stocks(),
        "dividend": ScreeningPresets.dividend_stocks(),
        "quality": ScreeningPresets.quality_stocks()
    }

    if screen_type not in preset_map:
        print(f"❌ 无效的筛选类型: {screen_type}")
        return None

    print(f"🔍 快速{screen_type}股筛选...")
    results = quantgpt.screen_stocks_basic(preset_map[screen_type])

    if results:
        print(f"✅ 找到 {len(results)} 只股票:")
        for stock in results[:5]:
            print(f"  {stock['symbol']}: {stock['fundamental_score']:.1f}分 - {stock.get('ai_recommendation', 'N/A')}")
    else:
        print("❌ 未找到符合条件的股票")

    return results

def quick_screen_enhanced(screen_type: str = "value", quantgpt=None,
                         custom_symbols=None, relaxed=False):
    """增强的快速筛选函数"""
    if quantgpt is None:
        quantgpt = QuantGPT()

    preset_map = {
        "value": ScreeningPresets.relaxed_value_stocks() if relaxed else ScreeningPresets.value_stocks(),
        "growth": ScreeningPresets.growth_stocks(),
        "dividend": ScreeningPresets.dividend_stocks(),
        "quality": ScreeningPresets.quality_stocks()
    }

    if screen_type not in preset_map:
        print(f"❌ 无效的筛选类型: {screen_type}")
        print("可用类型: value, growth, dividend, quality")
        return None

    print(f"🔍 {'宽松' if relaxed else '标准'}{screen_type}股筛选...")

    # 使用自定义股票池或默认股票池
    symbols = custom_symbols if custom_symbols else None

    results = quantgpt.screen_stocks_basic(preset_map[screen_type], symbols)

    if results:
        print(f"\n✅ 找到 {len(results)} 只符合条件的股票:")
        print("=" * 80)
        print(f"{'排名':<4} {'股票':<8} {'评分':<6} {'PE':<8} {'ROE':<8} {'AI建议':<15} {'行业':<15}")
        print("=" * 80)

        for i, stock in enumerate(results[:10], 1):  # 显示前10只
            pe_str = f"{stock.get('pe_ratio', 0):.1f}" if stock.get('pe_ratio') else "N/A"
            roe_str = f"{(stock.get('roe', 0) or 0)*100:.1f}%" if stock.get('roe') else "N/A"

            print(f"{i:<4} {stock['symbol']:<8} {stock['fundamental_score']:<6.1f} "
                  f"{pe_str:<8} {roe_str:<8} {stock.get('ai_recommendation', 'N/A'):<15} "
                  f"{stock.get('sector', 'Unknown')[:14]:<15}")
    else:
        print("❌ 未找到符合条件的股票")
        if not relaxed:
            print("💡 建议: 尝试使用宽松条件 quick_screen_enhanced('value', relaxed=True)")

    return results

def test_screening():
    """测试筛选功能"""
    print("🧪 测试筛选功能...")

    quantgpt = QuantGPT()

    # 测试少量股票
    test_symbols = ["AAPL", "JNJ", "KO", "PG", "WMT"]

    print("\n1. 测试标准价值股筛选...")
    results1 = quantgpt.screen_stocks_basic(ScreeningPresets.value_stocks(), test_symbols)
    print(f"标准条件结果: {len(results1)} 只")

    print("\n2. 测试宽松价值股筛选...")
    results2 = quantgpt.screen_stocks_basic(ScreeningPresets.relaxed_value_stocks(), test_symbols)
    print(f"宽松条件结果: {len(results2)} 只")

    return results1, results2

def interactive_session(quantgpt=None):
    """交互式会话"""
    if quantgpt is None:
        quantgpt = QuantGPT()

    print("🎯 欢迎使用QuantGPT交互系统!")
    print("输入 'help' 查看可用命令")

    while True:
        try:
            command = input("\nQuantGPT> ").strip().lower()

            if command == "quit" or command == "exit":
                print("👋 再见!")
                break

            elif command == "help":
                print("\n📖 可用命令:")
                print("analyze <股票代码>     - AI股票分析")
                print("fundamental <股票代码> - 基本面分析")
                print("sentiment <文本>      - 情感分析")
                print("backtest <股票> <策略> - 策略回测")
                print("compare <股票>         - 策略比较")
                print("screen <类型>         - 股票筛选 (value/growth/quality)")
                print("help                  - 显示帮助")
                print("quit                  - 退出")

            elif command.startswith("analyze "):
                symbol = command.split()[1].upper()
                result = quick_analyze(symbol, quantgpt)

            elif command.startswith("fundamental "):
                symbol = command.split()[1].upper()
                print(f"📈 获取 {symbol} 基本面数据...")
                result = quantgpt.get_fundamental_data(symbol)
                if "error" not in result:
                    print(f"✅ {symbol} 基本面分析:")
                    print(f"   公司: {result.get('company_name', 'N/A')}")
                    print(f"   行业: {result.get('sector', 'N/A')}")
                    print(f"   PE: {result.get('pe_ratio', 'N/A')}")
                    print(f"   ROE: {(result.get('roe', 0) or 0) * 100:.1f}%")
                    print(f"   评分: {result.get('fundamental_score', 0):.1f}/100")
                else:
                    print(f"❌ {result['error']}")

            elif command.startswith("sentiment "):
                text = command[10:]
                print("🧠 分析情感...")
                result = quantgpt.ai_engine.analyze_sentiment(text)
                print(f"✅ 情感分析结果:")
                print(f"   文本: {text}")
                print(f"   情感: {result['sentiment']}")
                print(f"   置信度: {result['confidence']:.2%}")

            elif command.startswith("backtest "):
                parts = command.split()
                if len(parts) >= 3:
                    symbol = parts[1].upper()
                    strategy = parts[2]
                    print(f"🔬 回测 {symbol} - {strategy}...")
                    result = quantgpt.run_strategy_backtest(symbol, strategy)
                    if "error" not in result:
                        metrics = result["metrics"]
                        print(f"✅ 回测结果:")
                        print(f"   总收益率: {metrics.get('total_return', 0):.2%}")
                        print(f"   夏普比率: {metrics.get('sharpe_ratio', 0):.3f}")
                        print(f"   最大回撤: {metrics.get('max_drawdown', 0):.2%}")
                    else:
                        print(f"❌ {result['error']}")
                else:
                    print("❌ 用法: backtest <股票代码> <策略名>")

            elif command.startswith("compare "):
                symbol = command.split()[1].upper()
                strategies = ["sma_crossover", "rsi", "bollinger_bands", "ai_sentiment"]
                print(f"📈 比较 {symbol} 的所有策略...")
                result = quantgpt.compare_strategies(symbol, strategies)
                if "error" not in result:
                    print(f"✅ 最佳策略: {result['best_strategy']}")
                    for strategy, data in result["strategies"].items():
                        metrics = data["metrics"]
                        print(f"   {strategy}: {metrics.get('total_return', 0):.2%}")
                else:
                    print(f"❌ {result['error']}")

            elif command.startswith("screen "):
                screen_type = command.split()[1] if len(command.split()) > 1 else "value"
                quick_screen(screen_type, quantgpt)

            else:
                print("❌ 无效命令，输入 'help' 查看帮助")

        except KeyboardInterrupt:
            print("\n👋 用户中断操作")
            break
        except Exception as e:
            print(f"❌ 错误: {e}")

# =====================================================
# 主函数
# =====================================================

def main():
    """主函数"""
    print("🎯 QuantGPT启动选项:")
    print("1. 快速启动")
    print("2. 交互模式")
    print("3. 自定义分析")

    try:
        choice = input("\n请选择 (1-3): ").strip()

        if choice == "1":
            quantgpt = quick_start()
            return quantgpt

        elif choice == "2":
            quantgpt = QuantGPT()
            interactive_session(quantgpt)
            return quantgpt

        elif choice == "3":
            print("🔧 自定义分析模式...")
            quantgpt = QuantGPT()

            while True:
                print("\n🎯 自定义分析:")
                print("- analyze <股票代码>: 完整分析")
                print("- screen <类型>: 股票筛选")
                print("- backtest <股票> <策略>: 回测")
                print("- interactive: 进入交互模式")
                print("- quit: 退出")

                cmd = input("\n自定义> ").strip().split()

                if not cmd:
                    continue
                elif cmd[0] == "quit":
                    break
                elif cmd[0] == "interactive":
                    interactive_session(quantgpt)
                    break
                elif cmd[0] == "analyze" and len(cmd) > 1:
                    quick_analyze(cmd[1], quantgpt)
                elif cmd[0] == "screen" and len(cmd) > 1:
                    quick_screen(cmd[1], quantgpt)
                elif cmd[0] == "backtest" and len(cmd) > 2:
                    result = quantgpt.run_strategy_backtest(cmd[1], cmd[2])
                    if "error" not in result:
                        metrics = result["metrics"]
                        print(f"✅ 回测结果: {metrics.get('total_return', 0):.2%}")
                    else:
                        print(f"❌ {result['error']}")
                else:
                    print("❌ 无效命令")

            return quantgpt
        else:
            print("❌ 无效选择")
            return None

    except KeyboardInterrupt:
        print("\n👋 用户取消操作")
        return None

if __name__ == "__main__":
    app = main()
else:
    print("🎉 QuantGPT系统已导入!")
    print("🚀 使用 quick_start() 快速开始")
    print("🎯 使用 interactive_session() 进入交互模式")
    print("📊 使用 quick_analyze('AAPL') 快速分析")
    print("🔍 使用 quick_screen('value') 快速筛选")
    print("🧪 使用 test_screening() 测试筛选功能")
    print("💡 使用 quick_screen_enhanced('value', relaxed=True) 宽松筛选")

print("\n✨ QuantGPT完整系统加载完成！")