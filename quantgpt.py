# -*- coding: utf-8 -*-
"""QuantGPT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EdZ5hIzcTkLy7fB3Awrt3oDZ3lP45j88
"""

# =====================================================
# QuantGPT - å®Œæ•´AIé‡åŒ–é‡‘èå¹³å°
# é›†æˆåŠŸèƒ½ï¼šAIåˆ†æ + ç­–ç•¥å›æµ‹ + å®æ—¶ç­›é€‰ + åŸºæœ¬é¢åˆ†æ + è¡Œä¸šè½®åŠ¨
# ä½œè€…ï¼šä¸“ä¸šAIé‡åŒ–å·¥ç¨‹å¸ˆ
# ç›®æ ‡ï¼šæ‰“é€ æœ€å…¨é¢çš„ä¸ªäººé‡åŒ–æŠ•èµ„å¹³å°
# =====================================================

import warnings
warnings.filterwarnings('ignore')

import torch
import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import json
import logging
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from transformers import pipeline, AutoTokenizer, AutoModelForSequenceClassification
import threading
import time
import requests

# æ‰©å±•çš„é»˜è®¤è‚¡ç¥¨æ± 
DEFAULT_STOCK_POOL = [
    # å¤§ç›˜ç§‘æŠ€è‚¡
    "AAPL", "GOOGL", "MSFT", "TSLA", "NVDA", "AMZN", "META", "NFLX",
    # ä¼ ç»Ÿä»·å€¼è‚¡
    "BRK-B", "JPM", "JNJ", "PG", "KO", "PFE", "XOM", "CVX", "WMT", "HD",
    # é‡‘èè‚¡
    "BAC", "WFC", "GS", "MS", "AXP",
    # å·¥ä¸šè‚¡
    "BA", "CAT", "GE", "MMM", "HON",
    # åŒ»ç–—è‚¡
    "UNH", "ABBV", "MRK", "TMO", "DHR",
    # æ¶ˆè´¹è‚¡
    "DIS", "MCD", "SBUX", "NKE", "COST",
    # èƒ½æºè‚¡
    "COP", "SLB", "EOG", "PSX",
    # é€šä¿¡è‚¡
    "VZ", "T", "CMCSA"
]

# =====================================================
# æ ¸å¿ƒé…ç½®ç±»
# =====================================================

@dataclass
class QuantGPTConfig:
    """QuantGPTé…ç½®ç±»"""
    initial_capital: float = 100000.0
    commission: float = 0.001
    slippage: float = 0.0005
    max_position_size: float = 0.2
    risk_free_rate: float = 0.02

    # AIæ¨¡å‹é…ç½®
    sentiment_model: str = "ProsusAI/finbert"
    device: str = "cuda" if torch.cuda.is_available() else "cpu"

    # æ•°æ®é…ç½®
    default_period: str = "2y"
    min_data_points: int = 200

@dataclass
class AdvancedScreeningCriteria:
    """é«˜çº§è‚¡ç¥¨ç­›é€‰æ¡ä»¶"""

    # åŸºæœ¬é¢æŒ‡æ ‡
    pe_ratio_min: Optional[float] = None
    pe_ratio_max: Optional[float] = None
    pb_ratio_min: Optional[float] = None
    pb_ratio_max: Optional[float] = None
    roe_min: Optional[float] = None
    roa_min: Optional[float] = None
    debt_to_equity_max: Optional[float] = None
    current_ratio_min: Optional[float] = None
    quick_ratio_min: Optional[float] = None

    # ç›ˆåˆ©èƒ½åŠ›
    gross_margin_min: Optional[float] = None
    operating_margin_min: Optional[float] = None
    net_margin_min: Optional[float] = None

    # æˆé•¿æ€§æŒ‡æ ‡
    revenue_growth_min: Optional[float] = None
    earnings_growth_min: Optional[float] = None

    # è‚¡æ¯æŒ‡æ ‡
    dividend_yield_min: Optional[float] = None
    payout_ratio_max: Optional[float] = None

    # æŠ€æœ¯æŒ‡æ ‡
    rsi_min: Optional[float] = None
    rsi_max: Optional[float] = None
    macd_signal: Optional[str] = None
    bollinger_position: Optional[str] = None

    # ä»·æ ¼å’Œå¸‚å€¼
    price_min: Optional[float] = None
    price_max: Optional[float] = None
    market_cap_min: Optional[float] = None
    market_cap_max: Optional[float] = None

    # æˆäº¤é‡
    volume_min: Optional[int] = None
    avg_volume_ratio_min: Optional[float] = None

    # ç§»åŠ¨å¹³å‡çº¿æ¡ä»¶
    above_sma_20: Optional[bool] = None
    above_sma_50: Optional[bool] = None
    sma_trend: Optional[str] = None

    # æ¶¨è·Œå¹…æ¡ä»¶
    change_percent_min: Optional[float] = None
    change_percent_max: Optional[float] = None

    # AIè¯„åˆ†æ¡ä»¶
    ai_score_min: Optional[float] = None
    recommendation_filter: Optional[List[str]] = None

    # è¡Œä¸šå’Œæ¿å—
    sectors: Optional[List[str]] = None
    exclude_sectors: Optional[List[str]] = None
    industries: Optional[List[str]] = None

    # åœ°åŒº
    countries: Optional[List[str]] = None
    exclude_countries: Optional[List[str]] = None

# =====================================================
# AIæƒ…æ„Ÿåˆ†æå¼•æ“
# =====================================================

class AIAnalysisEngine:
    """AIé©±åŠ¨çš„é‡‘èåˆ†æå¼•æ“"""

    def __init__(self, config: QuantGPTConfig):
        self.config = config
        self.setup_models()

    def setup_models(self):
        """åˆå§‹åŒ–AIæ¨¡å‹"""
        print("ğŸ¤– æ­£åœ¨åŠ è½½AIæ¨¡å‹...")

        try:
            self.sentiment_analyzer = pipeline(
                "sentiment-analysis",
                model=self.config.sentiment_model,
                return_all_scores=True,
                device=0 if self.config.device == "cuda" else -1
            )
            print("âœ… FinBERTæƒ…æ„Ÿåˆ†ææ¨¡å‹åŠ è½½æˆåŠŸ")

        except Exception as e:
            print(f"âš ï¸ AIæ¨¡å‹åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ: {e}")
            self.sentiment_analyzer = None

    def analyze_sentiment(self, text: str) -> Dict:
        """åˆ†æé‡‘èæ–‡æœ¬æƒ…æ„Ÿ"""
        if not self.sentiment_analyzer:
            return {"sentiment": "neutral", "confidence": 0.5, "error": "Model not available"}

        try:
            result = self.sentiment_analyzer(text)
            best_result = max(result[0], key=lambda x: x['score'])

            return {
                "sentiment": best_result['label'],
                "confidence": best_result['score'],
                "text_preview": text[:100] + "..." if len(text) > 100 else text,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            return {"sentiment": "neutral", "confidence": 0.5, "error": str(e)}

    def generate_market_insight(self, symbol: str, price_data: pd.DataFrame,
                              news_sentiment: float = 0.5) -> Dict:
        """ç”ŸæˆAIé©±åŠ¨çš„å¸‚åœºæ´å¯Ÿ"""

        # è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
        current_price = price_data['Close'].iloc[-1]
        prev_price = price_data['Close'].iloc[-2]
        price_change = (current_price - prev_price) / prev_price

        # è®¡ç®—ç§»åŠ¨å¹³å‡
        sma_20 = price_data['Close'].rolling(20).mean().iloc[-1]
        sma_50 = price_data['Close'].rolling(50).mean().iloc[-1]

        # è®¡ç®—RSI
        delta = price_data['Close'].diff()
        gain = delta.where(delta > 0, 0).rolling(14).mean()
        loss = -delta.where(delta < 0, 0).rolling(14).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        current_rsi = rsi.iloc[-1]

        # AIé©±åŠ¨çš„å»ºè®®ç”Ÿæˆ
        sentiment_score = news_sentiment
        technical_score = 0.5

        # æŠ€æœ¯é¢è¯„åˆ†
        if current_price > sma_20 > sma_50:
            technical_score += 0.3
        if current_rsi < 30:
            technical_score += 0.2
        elif current_rsi > 70:
            technical_score -= 0.2

        # ç»¼åˆè¯„åˆ†
        combined_score = (sentiment_score * 0.4 + technical_score * 0.6)

        # ç”Ÿæˆå»ºè®®
        if combined_score > 0.7:
            recommendation = "ğŸŸ¢ å¼ºçƒˆä¹°å…¥"
            reason = "æŠ€æœ¯é¢å’ŒåŸºæœ¬é¢éƒ½æ˜¾ç¤ºå¼ºåŠ²ä¸Šæ¶¨ä¿¡å·"
        elif combined_score > 0.6:
            recommendation = "ğŸŸ¡ ä¹°å…¥"
            reason = "æ€»ä½“è¶‹åŠ¿ç§¯æï¼Œå»ºè®®é€¢ä½ä¹°å…¥"
        elif combined_score < 0.3:
            recommendation = "ğŸ”´ å–å‡º"
            reason = "å¤šé‡è´Ÿé¢ä¿¡å·ï¼Œå»ºè®®å‡ä»“"
        elif combined_score < 0.4:
            recommendation = "ğŸŸ¡ è§‚æœ›"
            reason = "ä¿¡å·æ··åˆï¼Œå»ºè®®ç­‰å¾…æ›´æ˜ç¡®çš„æ–¹å‘"
        else:
            recommendation = "ğŸŸ¡ æŒæœ‰"
            reason = "å½“å‰è¶‹åŠ¿ä¸æ˜ç¡®ï¼Œç»´æŒç°æœ‰ä»“ä½"

        return {
            "symbol": symbol,
            "current_price": current_price,
            "price_change_pct": price_change * 100,
            "technical_indicators": {
                "sma_20": sma_20,
                "sma_50": sma_50,
                "rsi": current_rsi
            },
            "ai_scores": {
                "sentiment_score": sentiment_score,
                "technical_score": technical_score,
                "combined_score": combined_score
            },
            "recommendation": recommendation,
            "reasoning": reason,
            "confidence": abs(combined_score - 0.5) * 2,
            "timestamp": datetime.now().isoformat()
        }

# =====================================================
# æ•°æ®ç®¡ç†å™¨
# =====================================================

class DataManager:
    """é‡‘èæ•°æ®ç®¡ç†å™¨"""

    def __init__(self, config: QuantGPTConfig):
        self.config = config
        self.cache = {}

    def get_stock_data(self, symbol: str, period: str = None,
                      start: str = None, end: str = None) -> Optional[pd.DataFrame]:
        """è·å–è‚¡ç¥¨æ•°æ®"""
        period = period or self.config.default_period
        cache_key = f"{symbol}_{period}_{start}_{end}"

        if cache_key in self.cache:
            return self.cache[cache_key]

        try:
            ticker = yf.Ticker(symbol)

            if start and end:
                start_str = str(start) if not isinstance(start, str) else start
                end_str = str(end) if not isinstance(end, str) else end
                data = ticker.history(start=start_str, end=end_str)
            else:
                period_str = str(period) if not isinstance(period, str) else period
                data = ticker.history(period=period_str)

            if data.empty or len(data) < self.config.min_data_points:
                print(f"âš ï¸ {symbol} æ•°æ®ä¸è¶³ ({len(data)}ç‚¹ < {self.config.min_data_points}ç‚¹)")
                return None

            # æ•°æ®æ¸…æ´—
            for col in ['Open', 'High', 'Low', 'Close', 'Volume']:
                if col in data.columns:
                    data[col] = pd.to_numeric(data[col], errors='coerce')

            data = data.dropna()

            if len(data) < self.config.min_data_points:
                print(f"âš ï¸ {symbol} æ¸…æ´—åæ•°æ®ä¸è¶³ ({len(data)}ç‚¹ < {self.config.min_data_points}ç‚¹)")
                return None

            self.cache[cache_key] = data
            print(f"âœ… {symbol} æ•°æ®è·å–æˆåŠŸ: {len(data)} å¤©")
            return data

        except Exception as e:
            print(f"âŒ è·å– {symbol} æ•°æ®å¤±è´¥: {e}")
            return None

    def get_stock_info(self, symbol: str) -> Dict:
        """è·å–è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯"""
        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info
            return {
                "name": info.get("longName", symbol),
                "sector": info.get("sector", "Unknown"),
                "industry": info.get("industry", "Unknown"),
                "market_cap": info.get("marketCap", 0),
                "pe_ratio": info.get("trailingPE", 0),
                "dividend_yield": info.get("dividendYield", 0)
            }
        except:
            return {"name": symbol, "sector": "Unknown"}

# =====================================================
# æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å™¨
# =====================================================

class TechnicalIndicators:
    """æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å™¨"""

    @staticmethod
    def calculate_sma(data: pd.Series, window: int) -> pd.Series:
        """ç®€å•ç§»åŠ¨å¹³å‡"""
        return data.rolling(window=window).mean()

    @staticmethod
    def calculate_ema(data: pd.Series, window: int) -> pd.Series:
        """æŒ‡æ•°ç§»åŠ¨å¹³å‡"""
        return data.ewm(span=window, adjust=False).mean()

    @staticmethod
    def calculate_rsi(data: pd.Series, window: int = 14) -> pd.Series:
        """ç›¸å¯¹å¼ºå¼±æŒ‡æ•°"""
        delta = data.diff()
        gain = delta.where(delta > 0, 0)
        loss = -delta.where(delta < 0, 0)

        avg_gain = gain.rolling(window=window).mean()
        avg_loss = loss.rolling(window=window).mean()

        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    @staticmethod
    def calculate_macd(data: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Dict[str, pd.Series]:
        """MACDæŒ‡æ ‡"""
        ema_fast = TechnicalIndicators.calculate_ema(data, fast)
        ema_slow = TechnicalIndicators.calculate_ema(data, slow)

        macd = ema_fast - ema_slow
        signal_line = TechnicalIndicators.calculate_ema(macd, signal)
        histogram = macd - signal_line

        return {
            "macd": macd,
            "signal": signal_line,
            "histogram": histogram
        }

    @staticmethod
    def calculate_bollinger_bands(data: pd.Series, window: int = 20, num_std: float = 2) -> Dict[str, pd.Series]:
        """å¸ƒæ—å¸¦"""
        sma = TechnicalIndicators.calculate_sma(data, window)
        std = data.rolling(window=window).std()

        upper_band = sma + (std * num_std)
        lower_band = sma - (std * num_std)

        return {
            "upper": upper_band,
            "middle": sma,
            "lower": lower_band
        }

    @staticmethod
    def add_all_indicators(df: pd.DataFrame) -> pd.DataFrame:
        """ä¸ºæ•°æ®æ·»åŠ æ‰€æœ‰æŠ€æœ¯æŒ‡æ ‡"""
        df = df.copy()
        close = df['Close']

        # ç§»åŠ¨å¹³å‡
        df['SMA_20'] = TechnicalIndicators.calculate_sma(close, 20)
        df['SMA_50'] = TechnicalIndicators.calculate_sma(close, 50)
        df['SMA_200'] = TechnicalIndicators.calculate_sma(close, 200)

        df['EMA_12'] = TechnicalIndicators.calculate_ema(close, 12)
        df['EMA_26'] = TechnicalIndicators.calculate_ema(close, 26)

        # RSI
        df['RSI'] = TechnicalIndicators.calculate_rsi(close)

        # MACD
        macd_data = TechnicalIndicators.calculate_macd(close)
        df['MACD'] = macd_data['macd']
        df['MACD_Signal'] = macd_data['signal']
        df['MACD_Histogram'] = macd_data['histogram']

        # å¸ƒæ—å¸¦
        bb_data = TechnicalIndicators.calculate_bollinger_bands(close)
        df['BB_Upper'] = bb_data['upper']
        df['BB_Middle'] = bb_data['middle']
        df['BB_Lower'] = bb_data['lower']

        # æˆäº¤é‡æŒ‡æ ‡
        df['Volume_SMA'] = TechnicalIndicators.calculate_sma(df['Volume'], 20)

        return df

# =====================================================
# äº¤æ˜“ç­–ç•¥å¼•æ“
# =====================================================

class StrategyEngine:
    """äº¤æ˜“ç­–ç•¥å¼•æ“"""

    def __init__(self, config: QuantGPTConfig):
        self.config = config

    def sma_crossover_strategy(self, data: pd.DataFrame, short_window: int = 20,
                              long_window: int = 50) -> pd.DataFrame:
        """ç§»åŠ¨å¹³å‡äº¤å‰ç­–ç•¥"""
        df = data.copy()
        df = TechnicalIndicators.add_all_indicators(df)

        # ç”Ÿæˆä¿¡å·
        df['Signal'] = 0
        df['Signal'][short_window:] = np.where(
            df[f'SMA_{short_window}'][short_window:] > df[f'SMA_{long_window}'][short_window:], 1, 0
        )
        df['Position'] = df['Signal'].diff()

        return df

    def rsi_strategy(self, data: pd.DataFrame, rsi_oversold: int = 30,
                    rsi_overbought: int = 70) -> pd.DataFrame:
        """RSIç­–ç•¥"""
        df = data.copy()
        df = TechnicalIndicators.add_all_indicators(df)

        # ç”Ÿæˆä¿¡å·
        df['Signal'] = 0
        df.loc[df['RSI'] < rsi_oversold, 'Signal'] = 1
        df.loc[df['RSI'] > rsi_overbought, 'Signal'] = -1
        df['Position'] = df['Signal'].diff()

        return df

    def bollinger_bands_strategy(self, data: pd.DataFrame) -> pd.DataFrame:
        """å¸ƒæ—å¸¦å‡å€¼å›å½’ç­–ç•¥"""
        df = data.copy()
        df = TechnicalIndicators.add_all_indicators(df)

        # ç”Ÿæˆä¿¡å·
        df['Signal'] = 0
        df.loc[df['Close'] < df['BB_Lower'], 'Signal'] = 1
        df.loc[df['Close'] > df['BB_Upper'], 'Signal'] = -1
        df['Position'] = df['Signal'].diff()

        return df

    def ai_sentiment_strategy(self, data: pd.DataFrame, ai_engine: AIAnalysisEngine,
                             sentiment_threshold: float = 0.6) -> pd.DataFrame:
        """AIæƒ…æ„Ÿé©±åŠ¨ç­–ç•¥"""
        df = data.copy()
        df = TechnicalIndicators.add_all_indicators(df)

        # æ¨¡æ‹Ÿæ¯æ—¥æ–°é—»æƒ…æ„Ÿ
        np.random.seed(42)
        df['Sentiment_Score'] = np.random.uniform(0.3, 0.7, len(df))

        # ç”Ÿæˆä¿¡å·
        df['Signal'] = 0

        buy_condition = (
            (df['Sentiment_Score'] > sentiment_threshold) &
            (df['RSI'] < 50) &
            (df['Close'] > df['SMA_20'])
        )
        df.loc[buy_condition, 'Signal'] = 1

        sell_condition = (
            (df['Sentiment_Score'] < (1 - sentiment_threshold)) &
            (df['RSI'] > 50)
        )
        df.loc[sell_condition, 'Signal'] = -1

        df['Position'] = df['Signal'].diff()

        return df

# =====================================================
# å›æµ‹å¼•æ“
# =====================================================

class BacktestEngine:
    """ä¸“ä¸šçº§å›æµ‹å¼•æ“"""

    def __init__(self, config: QuantGPTConfig):
        self.config = config
        self.reset()

    def reset(self):
        """é‡ç½®å›æµ‹çŠ¶æ€"""
        self.capital = self.config.initial_capital
        self.positions = 0
        self.trades = []
        self.portfolio_history = []

    def execute_backtest(self, strategy_data: pd.DataFrame, symbol: str) -> Dict:
        """æ‰§è¡Œå›æµ‹"""
        self.reset()

        portfolio_values = []
        cash_history = []
        position_history = []

        for i, (date, row) in enumerate(strategy_data.iterrows()):
            current_price = row['Close']
            position_change = row.get('Position', 0)

            # ä¿®å¤æ•°æ®ç±»å‹
            if isinstance(position_change, pd.Series):
                position_change = position_change.iloc[0] if not position_change.empty else 0
            elif not isinstance(position_change, (int, float)):
                position_change = 0

            try:
                position_change = int(position_change)
            except:
                position_change = 0

            # æ‰§è¡Œäº¤æ˜“
            if position_change == 1 and self.positions == 0:  # ä¹°å…¥ä¿¡å·
                shares_to_buy = int((self.capital * self.config.max_position_size) /
                                  (current_price * (1 + self.config.commission + self.config.slippage)))
                if shares_to_buy > 0:
                    cost = shares_to_buy * current_price * (1 + self.config.commission + self.config.slippage)
                    if cost <= self.capital:
                        self.capital -= cost
                        self.positions = shares_to_buy

                        self.trades.append({
                            'date': date,
                            'action': 'BUY',
                            'shares': shares_to_buy,
                            'price': current_price,
                            'value': cost
                        })

            elif position_change == -1 and self.positions > 0:  # å–å‡ºä¿¡å·
                revenue = self.positions * current_price * (1 - self.config.commission - self.config.slippage)
                self.capital += revenue

                self.trades.append({
                    'date': date,
                    'action': 'SELL',
                    'shares': self.positions,
                    'price': current_price,
                    'value': revenue
                })

                self.positions = 0

            # è®¡ç®—å½“å‰ç»„åˆä»·å€¼
            portfolio_value = self.capital + self.positions * current_price
            portfolio_values.append(portfolio_value)
            cash_history.append(self.capital)
            position_history.append(self.positions)

        # æ·»åŠ å†å²æ•°æ®åˆ°DataFrame
        strategy_data = strategy_data.copy()
        strategy_data['Portfolio_Value'] = portfolio_values
        strategy_data['Cash'] = cash_history
        strategy_data['Positions'] = position_history

        # è®¡ç®—ç»©æ•ˆæŒ‡æ ‡
        metrics = self.calculate_performance_metrics(strategy_data, symbol)

        return {
            'data': strategy_data,
            'trades': self.trades,
            'metrics': metrics,
            'final_value': portfolio_values[-1] if portfolio_values else self.config.initial_capital
        }

    def calculate_performance_metrics(self, data: pd.DataFrame, symbol: str) -> Dict:
        """è®¡ç®—è¯¦ç»†çš„ç»©æ•ˆæŒ‡æ ‡"""
        if 'Portfolio_Value' not in data.columns or data['Portfolio_Value'].empty:
            return {}

        portfolio_values = data['Portfolio_Value']
        returns = portfolio_values.pct_change().dropna()

        # åŸºç¡€æŒ‡æ ‡
        total_return = (portfolio_values.iloc[-1] - self.config.initial_capital) / self.config.initial_capital
        trading_days = len(data)
        annual_return = (1 + total_return) ** (252 / trading_days) - 1

        # é£é™©æŒ‡æ ‡
        annual_volatility = returns.std() * np.sqrt(252) if len(returns) > 1 else 0

        # å¤æ™®æ¯”ç‡
        excess_returns = returns - self.config.risk_free_rate / 252
        sharpe_ratio = (excess_returns.mean() / excess_returns.std() * np.sqrt(252)) if excess_returns.std() != 0 else 0

        # æœ€å¤§å›æ’¤
        cumulative_returns = (1 + returns).cumprod()
        rolling_max = cumulative_returns.expanding().max()
        drawdowns = (cumulative_returns - rolling_max) / rolling_max
        max_drawdown = drawdowns.min()

        # äº¤æ˜“ç»Ÿè®¡
        total_trades = len(self.trades) // 2 if len(self.trades) > 1 else 0

        # è®¡ç®—èƒœç‡
        winning_trades = 0
        if total_trades > 0:
            for i in range(0, len(self.trades) - 1, 2):
                if i + 1 < len(self.trades):
                    buy_price = self.trades[i]['price']
                    sell_price = self.trades[i + 1]['price']
                    if sell_price > buy_price:
                        winning_trades += 1

        win_rate = winning_trades / total_trades if total_trades > 0 else 0

        # åŸºå‡†æ¯”è¾ƒ
        benchmark_return = (data['Close'].iloc[-1] - data['Close'].iloc[0]) / data['Close'].iloc[0]
        alpha = annual_return - benchmark_return

        return {
            'symbol': symbol,
            'total_return': total_return,
            'annual_return': annual_return,
            'benchmark_return': benchmark_return,
            'alpha': alpha,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'total_trades': total_trades,
            'final_value': portfolio_values.iloc[-1],
            'days_traded': trading_days
        }

# =====================================================
# åŸºæœ¬é¢åˆ†æå¼•æ“
# =====================================================

class FundamentalAnalysisEngine:
    """åŸºæœ¬é¢åˆ†æå¼•æ“"""

    def __init__(self):
        self.cache = {}
        self.cache_timeout = 3600

    def get_fundamental_data(self, symbol: str) -> Dict:
        """è·å–è‚¡ç¥¨åŸºæœ¬é¢æ•°æ®"""
        cache_key = f"fundamental_{symbol}_{datetime.now().hour}"

        if cache_key in self.cache:
            return self.cache[cache_key]

        try:
            ticker = yf.Ticker(symbol)
            info = ticker.info

            fundamental_data = {
                "symbol": symbol,
                "company_name": info.get("longName", symbol),

                # ä¼°å€¼æŒ‡æ ‡
                "pe_ratio": info.get("trailingPE", None),
                "forward_pe": info.get("forwardPE", None),
                "pb_ratio": info.get("priceToBook", None),
                "ps_ratio": info.get("priceToSalesTrailing12Months", None),
                "peg_ratio": info.get("pegRatio", None),

                # ç›ˆåˆ©èƒ½åŠ›
                "roe": info.get("returnOnEquity", None),
                "roa": info.get("returnOnAssets", None),
                "gross_margin": info.get("grossMargins", None),
                "operating_margin": info.get("operatingMargins", None),
                "net_margin": info.get("profitMargins", None),

                # è´¢åŠ¡å¥åº·
                "debt_to_equity": info.get("debtToEquity", None),
                "current_ratio": info.get("currentRatio", None),
                "quick_ratio": info.get("quickRatio", None),
                "cash_per_share": info.get("totalCashPerShare", None),

                # æˆé•¿æ€§
                "revenue_growth": info.get("revenueGrowth", None),
                "earnings_growth": info.get("earningsGrowth", None),

                # è‚¡æ¯
                "dividend_yield": info.get("dividendYield", None),
                "payout_ratio": info.get("payoutRatio", None),
                "dividend_rate": info.get("dividendRate", None),

                # å¸‚åœºæ•°æ®
                "market_cap": info.get("marketCap", None),
                "enterprise_value": info.get("enterpriseValue", None),
                "shares_outstanding": info.get("sharesOutstanding", None),

                # è¡Œä¸šä¿¡æ¯
                "sector": info.get("sector", "Unknown"),
                "industry": info.get("industry", "Unknown"),
                "country": info.get("country", "Unknown"),

                # åˆ†æå¸ˆé¢„æœŸ
                "target_price": info.get("targetMeanPrice", None),
                "recommendation": info.get("recommendationMean", None),

                "last_updated": datetime.now().isoformat()
            }

            # è®¡ç®—æ´¾ç”ŸæŒ‡æ ‡
            fundamental_data.update(self._calculate_derived_metrics(fundamental_data, info))

            # ç¼“å­˜æ•°æ®
            self.cache[cache_key] = fundamental_data

            return fundamental_data

        except Exception as e:
            print(f"âŒ è·å– {symbol} åŸºæœ¬é¢æ•°æ®å¤±è´¥: {e}")
            return {"symbol": symbol, "error": str(e)}

    def _calculate_derived_metrics(self, data: Dict, info: Dict) -> Dict:
        """è®¡ç®—æ´¾ç”Ÿçš„åŸºæœ¬é¢æŒ‡æ ‡"""
        derived = {}

        try:
            # è®¡ç®—è‚¡ç¥¨è¯„çº§ (1-100åˆ†)
            score = 50

            # PEä¼°å€¼è¯„åˆ†
            pe = data.get("pe_ratio")
            if pe and 0 < pe < 15:
                score += 15
            elif pe and 15 <= pe <= 25:
                score += 10
            elif pe and pe > 30:
                score -= 10

            # ROEè¯„åˆ†
            roe = data.get("roe")
            if roe and roe > 0.2:
                score += 15
            elif roe and roe > 0.15:
                score += 10
            elif roe and roe < 0.1:
                score -= 5

            # å€ºåŠ¡è¯„åˆ†
            debt_eq = data.get("debt_to_equity")
            if debt_eq is not None:
                if debt_eq < 0.3:
                    score += 10
                elif debt_eq > 1.0:
                    score -= 10

            # æˆé•¿æ€§è¯„åˆ†
            rev_growth = data.get("revenue_growth")
            if rev_growth and rev_growth > 0.15:
                score += 10
            elif rev_growth and rev_growth > 0.05:
                score += 5
            elif rev_growth and rev_growth < 0:
                score -= 10

            derived["fundamental_score"] = max(0, min(100, score))

            # æŠ•èµ„é£æ ¼åˆ†ç±»
            pe = data.get("pe_ratio", 0)
            pb = data.get("pb_ratio", 0)
            growth = data.get("revenue_growth", 0)

            if pe and pb and pe < 15 and pb < 2:
                derived["investment_style"] = "Deep Value"
            elif pe and pb and pe < 20 and pb < 3:
                derived["investment_style"] = "Value"
            elif growth and growth > 0.2:
                derived["investment_style"] = "Growth"
            elif growth and growth > 0.1:
                derived["investment_style"] = "GARP"
            else:
                derived["investment_style"] = "Balanced"

            # è´¨é‡è¯„çº§
            roe = data.get("roe", 0)
            debt_eq = data.get("debt_to_equity", float('inf'))
            current_ratio = data.get("current_ratio", 0)

            quality_score = 0
            if roe and roe > 0.15: quality_score += 1
            if debt_eq and debt_eq < 0.5: quality_score += 1
            if current_ratio and current_ratio > 1.5: quality_score += 1

            quality_map = {0: "Poor", 1: "Fair", 2: "Good", 3: "Excellent"}
            derived["quality_rating"] = quality_map.get(quality_score, "Unknown")

        except Exception as e:
            print(f"è®¡ç®—æ´¾ç”ŸæŒ‡æ ‡é”™è¯¯: {e}")

        return derived

# =====================================================
# è‚¡ç¥¨ç­›é€‰é¢„è®¾
# =====================================================

class ScreeningPresets:
    """å®Œæ•´çš„ç­›é€‰é¢„è®¾"""

    @staticmethod
    def value_stocks() -> AdvancedScreeningCriteria:
        """ä»·å€¼è‚¡ç­›é€‰æ¡ä»¶"""
        return AdvancedScreeningCriteria(
            pe_ratio_max=20,          # æ”¾å®½åˆ°PE < 20
            pb_ratio_max=3,           # æ”¾å®½åˆ°PB < 3
            debt_to_equity_max=1.0,   # æ”¾å®½å€ºåŠ¡æ¯”
            roe_min=8,                # é™ä½ROEè¦æ±‚
            dividend_yield_min=1,     # é™ä½è‚¡æ¯è¦æ±‚
            market_cap_min=5          # é™ä½å¸‚å€¼è¦æ±‚
        )

    @staticmethod
    def relaxed_value_stocks() -> AdvancedScreeningCriteria:
        """æ›´å®½æ¾çš„ä»·å€¼è‚¡æ¡ä»¶"""
        return AdvancedScreeningCriteria(
            pe_ratio_max=25,
            pb_ratio_max=4,
            debt_to_equity_max=1.5,
            roe_min=5,
            market_cap_min=1
        )

    @staticmethod
    def growth_stocks() -> AdvancedScreeningCriteria:
        """æˆé•¿è‚¡ç­›é€‰æ¡ä»¶"""
        return AdvancedScreeningCriteria(
            revenue_growth_min=15,
            earnings_growth_min=15,
            roe_min=15,
            gross_margin_min=40,
            debt_to_equity_max=0.3,
            pe_ratio_max=40
        )

    @staticmethod
    def dividend_stocks() -> AdvancedScreeningCriteria:
        """åˆ†çº¢è‚¡ç­›é€‰æ¡ä»¶"""
        return AdvancedScreeningCriteria(
            dividend_yield_min=3,
            payout_ratio_max=70,
            debt_to_equity_max=0.6,
            current_ratio_min=1.5,
            roe_min=12
        )

    @staticmethod
    def quality_stocks() -> AdvancedScreeningCriteria:
        """ä¼˜è´¨è‚¡ç­›é€‰æ¡ä»¶"""
        return AdvancedScreeningCriteria(
            roe_min=20,
            roa_min=10,
            debt_to_equity_max=0.3,
            current_ratio_min=2,
            gross_margin_min=50,
            operating_margin_min=20,
            net_margin_min=15
        )

    @staticmethod
    def technical_momentum() -> AdvancedScreeningCriteria:
        """æŠ€æœ¯åŠ¨é‡ç­›é€‰æ¡ä»¶"""
        return AdvancedScreeningCriteria(
            rsi_min=50,
            rsi_max=80,
            above_sma_20=True,
            above_sma_50=True,
            ai_score_min=60,
            avg_volume_ratio_min=1.2
        )

# =====================================================
# ä¸»åº”ç”¨ç±» (å®Œæ•´ç‰ˆ)
# =====================================================

class QuantGPT:
    """QuantGPTä¸»åº”ç”¨ç±» - å®Œæ•´ç‰ˆ"""

    def __init__(self, config: QuantGPTConfig = None):
        self.config = config or QuantGPTConfig()
        self.ai_engine = AIAnalysisEngine(self.config)
        self.data_manager = DataManager(self.config)
        self.strategy_engine = StrategyEngine(self.config)
        self.backtest_engine = BacktestEngine(self.config)
        self.fundamental_engine = FundamentalAnalysisEngine()

        print("ğŸš€ QuantGPTå®Œæ•´ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼")
        print(f"ğŸ’° åˆå§‹èµ„é‡‘: ${self.config.initial_capital:,.2f}")
        print(f"ğŸ¤– AIæ¨¡å‹: {self.config.sentiment_model}")
        print(f"âš¡ è®¾å¤‡: {self.config.device}")
        print("\nğŸ¯ ç³»ç»ŸåŠŸèƒ½:")
        print("  âœ… AIæƒ…æ„Ÿåˆ†æä¸æ™ºèƒ½å»ºè®®")
        print("  âœ… å¤šç­–ç•¥å›æµ‹ä¸ç»©æ•ˆåˆ†æ")
        print("  âœ… åŸºæœ¬é¢æ·±åº¦åˆ†æ")
        print("  âœ… æŠ€æœ¯æŒ‡æ ‡åˆ†æ")
        print("  âœ… æŠ•èµ„ç»„åˆç®¡ç†")

    def analyze_stock(self, symbol: str, period: str = "1y") -> Dict:
        """åˆ†æå•åªè‚¡ç¥¨ - å¢å¼ºç‰ˆ"""
        print(f"ğŸ“Š æ­£åœ¨åˆ†æ {symbol}...")

        # è·å–æ•°æ®
        data = self.data_manager.get_stock_data(symbol, period)
        if data is None:
            return {"error": f"æ— æ³•è·å–{symbol}æ•°æ®"}

        # è·å–è‚¡ç¥¨ä¿¡æ¯
        stock_info = self.data_manager.get_stock_info(symbol)

        # AIåˆ†æ
        insight = self.ai_engine.generate_market_insight(symbol, data)

        # åŸºæœ¬é¢åˆ†æ
        fundamental_data = self.fundamental_engine.get_fundamental_data(symbol)

        return {
            "symbol": symbol,
            "stock_info": stock_info,
            "data": data,
            "ai_insight": insight,
            "fundamental_analysis": fundamental_data,
            "analysis_date": datetime.now().isoformat()
        }

    def run_strategy_backtest(self, symbol: str, strategy_name: str,
                             period: str = "2y", **strategy_params) -> Dict:
        """è¿è¡Œç­–ç•¥å›æµ‹"""
        print(f"ğŸ”¬ æ­£åœ¨å›æµ‹ {symbol} - {strategy_name}...")

        # è·å–æ•°æ®
        data = self.data_manager.get_stock_data(symbol, period)
        if data is None:
            return {"error": f"æ— æ³•è·å–{symbol}æ•°æ®"}

        # é€‰æ‹©ç­–ç•¥
        if strategy_name == "sma_crossover":
            strategy_data = self.strategy_engine.sma_crossover_strategy(data, **strategy_params)
        elif strategy_name == "rsi":
            strategy_data = self.strategy_engine.rsi_strategy(data, **strategy_params)
        elif strategy_name == "bollinger_bands":
            strategy_data = self.strategy_engine.bollinger_bands_strategy(data, **strategy_params)
        elif strategy_name == "ai_sentiment":
            strategy_data = self.strategy_engine.ai_sentiment_strategy(data, self.ai_engine, **strategy_params)
        else:
            return {"error": f"æœªçŸ¥ç­–ç•¥: {strategy_name}"}

        # æ‰§è¡Œå›æµ‹
        backtest_result = self.backtest_engine.execute_backtest(strategy_data, symbol)
        backtest_result['strategy_name'] = strategy_name
        backtest_result['strategy_params'] = strategy_params

        return backtest_result

    def compare_strategies(self, symbol: str, strategies: List[str],
                          period: str = "2y") -> Dict:
        """æ¯”è¾ƒå¤šä¸ªç­–ç•¥"""
        print(f"ğŸ“ˆ æ­£åœ¨æ¯”è¾ƒ {symbol} çš„ {len(strategies)} ä¸ªç­–ç•¥...")

        results = {}
        for strategy in strategies:
            result = self.run_strategy_backtest(symbol, strategy, period)
            if "error" not in result:
                results[strategy] = result

        if not results:
            return {"error": "æ‰€æœ‰ç­–ç•¥éƒ½å¤±è´¥äº†"}

        return {
            "symbol": symbol,
            "strategies": results,
            "best_strategy": max(results.keys(),
                               key=lambda x: results[x]['metrics'].get('sharpe_ratio', 0))
        }

    def screen_stocks_basic(self, criteria: AdvancedScreeningCriteria, symbols: List[str] = None) -> List[Dict]:
        """æ”¹è¿›çš„è‚¡ç¥¨ç­›é€‰åŠŸèƒ½"""
        if symbols is None:
            symbols = DEFAULT_STOCK_POOL

        results = []
        total_processed = 0
        successful_analyses = 0

        print(f"ğŸ” å¼€å§‹ç­›é€‰ {len(symbols)} åªè‚¡ç¥¨...")

        for i, symbol in enumerate(symbols, 1):
            try:
                print(f"å¤„ç†è¿›åº¦: {i}/{len(symbols)} - {symbol}")
                total_processed += 1

                # è·å–åŸºæœ¬é¢æ•°æ®
                fundamental = self.fundamental_engine.get_fundamental_data(symbol)
                if "error" in fundamental:
                    print(f"âš ï¸ {symbol}: åŸºæœ¬é¢æ•°æ®è·å–å¤±è´¥")
                    continue

                # æ·»åŠ è°ƒè¯•ä¿¡æ¯
                pe = fundamental.get("pe_ratio")
                roe = fundamental.get("roe")
                print(f"   {symbol}: PE={pe}, ROE={roe}")

                # æ£€æŸ¥ç­›é€‰æ¡ä»¶ - æ”¹è¿›ç‰ˆæœ¬
                if self._meets_criteria_improved(fundamental, criteria, symbol):
                    successful_analyses += 1

                    # ç®€åŒ–AIåˆ†æï¼ˆé¿å…é¢å¤–å¤±è´¥ç‚¹ï¼‰
                    try:
                        data = self.data_manager.get_stock_data(symbol, "3mo")
                        if data is not None:
                            insight = self.ai_engine.generate_market_insight(symbol, data)
                            ai_recommendation = insight["recommendation"]
                            ai_confidence = insight["confidence"]
                        else:
                            ai_recommendation = "æ•°æ®ä¸è¶³"
                            ai_confidence = 0
                    except:
                        ai_recommendation = "åˆ†æå¤±è´¥"
                        ai_confidence = 0

                    results.append({
                        "symbol": symbol,
                        "fundamental_score": fundamental.get("fundamental_score", 0),
                        "ai_recommendation": ai_recommendation,
                        "ai_confidence": ai_confidence,
                        "pe_ratio": pe,
                        "roe": roe,
                        "sector": fundamental.get("sector", "Unknown"),
                        "investment_style": fundamental.get("investment_style", "Unknown"),
                        "quality_rating": fundamental.get("quality_rating", "Unknown")
                    })
                    print(f"âœ… {symbol}: ç¬¦åˆæ¡ä»¶")
                else:
                    print(f"âŒ {symbol}: ä¸ç¬¦åˆç­›é€‰æ¡ä»¶")

            except Exception as e:
                print(f"âŒ å¤„ç†{symbol}æ—¶å‡ºé”™: {e}")
                continue

        print(f"\nğŸ“Š ç­›é€‰å®Œæˆ:")
        print(f"   æ€»å¤„ç†: {total_processed}")
        print(f"   æˆåŠŸåˆ†æ: {successful_analyses}")
        print(f"   ç¬¦åˆæ¡ä»¶: {len(results)}")

        # æŒ‰åŸºæœ¬é¢è¯„åˆ†æ’åº
        results.sort(key=lambda x: x.get("fundamental_score", 0), reverse=True)
        return results

    def _meets_criteria_improved(self, data: Dict, criteria: AdvancedScreeningCriteria,
                                symbol: str = "") -> bool:
        """æ”¹è¿›çš„ç­›é€‰æ¡ä»¶æ£€æŸ¥"""
        debug_info = []

        # PEæ¯”ç‡ç­›é€‰
        pe = data.get("pe_ratio")
        if criteria.pe_ratio_min:
            if not pe or pe < criteria.pe_ratio_min:
                debug_info.append(f"PEè¿‡ä½: {pe} < {criteria.pe_ratio_min}")
                return False
        if criteria.pe_ratio_max:
            if not pe or pe > criteria.pe_ratio_max:
                debug_info.append(f"PEè¿‡é«˜: {pe} > {criteria.pe_ratio_max}")
                return False

        # ROEç­›é€‰ - ä¿®å¤å•ä½é—®é¢˜
        roe = data.get("roe")
        if criteria.roe_min:
            if not roe:
                debug_info.append("ROEæ•°æ®ç¼ºå¤±")
                return False

            # å¤„ç†ROEçš„ä¸åŒæ ¼å¼ï¼ˆç™¾åˆ†æ¯” vs å°æ•°ï¼‰
            roe_value = roe
            if roe_value < 1:  # å¦‚æœæ˜¯å°æ•°å½¢å¼ï¼Œè½¬æ¢ä¸ºç™¾åˆ†æ¯”
                roe_value = roe_value * 100

            if roe_value < criteria.roe_min:
                debug_info.append(f"ROEè¿‡ä½: {roe_value:.1f}% < {criteria.roe_min}%")
                return False

        # å€ºåŠ¡è‚¡æƒæ¯”ç­›é€‰
        debt_eq = data.get("debt_to_equity")
        if criteria.debt_to_equity_max:
            if debt_eq and debt_eq > criteria.debt_to_equity_max:
                debug_info.append(f"å€ºåŠ¡æ¯”è¿‡é«˜: {debt_eq} > {criteria.debt_to_equity_max}")
                return False

        # è‚¡æ¯ç‡ç­›é€‰ - ä¿®å¤å•ä½é—®é¢˜
        dividend_yield = data.get("dividend_yield")
        if criteria.dividend_yield_min:
            if not dividend_yield:
                debug_info.append("è‚¡æ¯ç‡æ•°æ®ç¼ºå¤±")
                return False

            # å¤„ç†è‚¡æ¯ç‡çš„ä¸åŒæ ¼å¼
            dividend_value = dividend_yield
            if dividend_value < 1:  # å¦‚æœæ˜¯å°æ•°å½¢å¼ï¼Œè½¬æ¢ä¸ºç™¾åˆ†æ¯”
                dividend_value = dividend_value * 100

            if dividend_value < criteria.dividend_yield_min:
                debug_info.append(f"è‚¡æ¯ç‡è¿‡ä½: {dividend_value:.1f}% < {criteria.dividend_yield_min}%")
                return False

        # å¸‚å€¼ç­›é€‰
        market_cap = data.get("market_cap")
        if criteria.market_cap_min:
            if not market_cap or market_cap < criteria.market_cap_min * 1e9:  # è½¬æ¢ä¸ºå®é™…æ•°å€¼
                debug_info.append(f"å¸‚å€¼è¿‡ä½")
                return False

        if debug_info:
            print(f"   {symbol} ç­›é€‰å¤±è´¥: {'; '.join(debug_info)}")

        return True

    def get_fundamental_data(self, symbol: str) -> Dict:
        """è·å–åŸºæœ¬é¢æ•°æ®"""
        return self.fundamental_engine.get_fundamental_data(symbol)

# =====================================================
# ä¾¿æ·å‡½æ•°
# =====================================================

def quick_start():
    """å¿«é€Ÿå¯åŠ¨QuantGPT"""
    print("ğŸš€ QuantGPTå¿«é€Ÿå¯åŠ¨...")

    quantgpt = QuantGPT()

    print("\nğŸ“Š å¿«é€Ÿæ¼”ç¤º - AAPLåˆ†æ...")
    apple_result = quantgpt.analyze_stock("AAPL")

    if "error" not in apple_result:
        insight = apple_result["ai_insight"]
        print(f"âœ… AAPL AIå»ºè®®: {insight['recommendation']}")
        print(f"ğŸ“ ç†ç”±: {insight['reasoning']}")

        if "fundamental_analysis" in apple_result and "error" not in apple_result["fundamental_analysis"]:
            fund = apple_result["fundamental_analysis"]
            print(f"ğŸ’ åŸºæœ¬é¢è¯„åˆ†: {fund.get('fundamental_score', 0):.1f}/100")

    print("\nğŸ”¬ å¿«é€Ÿæ¼”ç¤º - ç­–ç•¥å›æµ‹...")
    backtest_result = quantgpt.run_strategy_backtest("AAPL", "sma_crossover")

    if "error" not in backtest_result:
        metrics = backtest_result["metrics"]
        print(f"âœ… å›æµ‹å®Œæˆ!")
        print(f"ğŸ“ˆ æ€»æ”¶ç›Šç‡: {metrics.get('total_return', 0):.2%}")
        print(f"ğŸ“Š å¤æ™®æ¯”ç‡: {metrics.get('sharpe_ratio', 0):.3f}")

    print("\nğŸ” å¿«é€Ÿæ¼”ç¤º - ä»·å€¼è‚¡ç­›é€‰...")
    screening_result = quantgpt.screen_stocks_basic(ScreeningPresets.value_stocks())

    if screening_result:
        print(f"âœ… æ‰¾åˆ° {len(screening_result)} åªä»·å€¼è‚¡:")
        for stock in screening_result[:3]:
            print(f"   {stock['symbol']}: {stock['fundamental_score']:.1f}åˆ†")

    print("\nğŸ‰ QuantGPTå·²å‡†å¤‡å°±ç»ª!")
    return quantgpt

def quick_analyze(symbol: str, quantgpt=None):
    """å¿«é€Ÿåˆ†æå•åªè‚¡ç¥¨"""
    if quantgpt is None:
        quantgpt = QuantGPT()

    print(f"ğŸ” å¿«é€Ÿåˆ†æ {symbol}...")
    result = quantgpt.analyze_stock(symbol)

    if "error" not in result:
        insight = result["ai_insight"]
        print(f"âœ… {symbol}:")
        print(f"   ä»·æ ¼: ${insight['current_price']:.2f}")
        print(f"   å»ºè®®: {insight['recommendation']}")
        print(f"   ç½®ä¿¡åº¦: {insight['confidence']:.1%}")

        if "fundamental_analysis" in result and "error" not in result["fundamental_analysis"]:
            fund = result["fundamental_analysis"]
            print(f"   åŸºæœ¬é¢è¯„åˆ†: {fund.get('fundamental_score', 0):.1f}/100")
    else:
        print(f"âŒ {result['error']}")

    return result

def quick_screen(screen_type: str = "value", quantgpt=None):
    """å¿«é€Ÿç­›é€‰è‚¡ç¥¨"""
    if quantgpt is None:
        quantgpt = QuantGPT()

    preset_map = {
        "value": ScreeningPresets.value_stocks(),
        "growth": ScreeningPresets.growth_stocks(),
        "dividend": ScreeningPresets.dividend_stocks(),
        "quality": ScreeningPresets.quality_stocks()
    }

    if screen_type not in preset_map:
        print(f"âŒ æ— æ•ˆçš„ç­›é€‰ç±»å‹: {screen_type}")
        return None

    print(f"ğŸ” å¿«é€Ÿ{screen_type}è‚¡ç­›é€‰...")
    results = quantgpt.screen_stocks_basic(preset_map[screen_type])

    if results:
        print(f"âœ… æ‰¾åˆ° {len(results)} åªè‚¡ç¥¨:")
        for stock in results[:5]:
            print(f"  {stock['symbol']}: {stock['fundamental_score']:.1f}åˆ† - {stock.get('ai_recommendation', 'N/A')}")
    else:
        print("âŒ æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„è‚¡ç¥¨")

    return results

def quick_screen_enhanced(screen_type: str = "value", quantgpt=None,
                         custom_symbols=None, relaxed=False):
    """å¢å¼ºçš„å¿«é€Ÿç­›é€‰å‡½æ•°"""
    if quantgpt is None:
        quantgpt = QuantGPT()

    preset_map = {
        "value": ScreeningPresets.relaxed_value_stocks() if relaxed else ScreeningPresets.value_stocks(),
        "growth": ScreeningPresets.growth_stocks(),
        "dividend": ScreeningPresets.dividend_stocks(),
        "quality": ScreeningPresets.quality_stocks()
    }

    if screen_type not in preset_map:
        print(f"âŒ æ— æ•ˆçš„ç­›é€‰ç±»å‹: {screen_type}")
        print("å¯ç”¨ç±»å‹: value, growth, dividend, quality")
        return None

    print(f"ğŸ” {'å®½æ¾' if relaxed else 'æ ‡å‡†'}{screen_type}è‚¡ç­›é€‰...")

    # ä½¿ç”¨è‡ªå®šä¹‰è‚¡ç¥¨æ± æˆ–é»˜è®¤è‚¡ç¥¨æ± 
    symbols = custom_symbols if custom_symbols else None

    results = quantgpt.screen_stocks_basic(preset_map[screen_type], symbols)

    if results:
        print(f"\nâœ… æ‰¾åˆ° {len(results)} åªç¬¦åˆæ¡ä»¶çš„è‚¡ç¥¨:")
        print("=" * 80)
        print(f"{'æ’å':<4} {'è‚¡ç¥¨':<8} {'è¯„åˆ†':<6} {'PE':<8} {'ROE':<8} {'AIå»ºè®®':<15} {'è¡Œä¸š':<15}")
        print("=" * 80)

        for i, stock in enumerate(results[:10], 1):  # æ˜¾ç¤ºå‰10åª
            pe_str = f"{stock.get('pe_ratio', 0):.1f}" if stock.get('pe_ratio') else "N/A"
            roe_str = f"{(stock.get('roe', 0) or 0)*100:.1f}%" if stock.get('roe') else "N/A"

            print(f"{i:<4} {stock['symbol']:<8} {stock['fundamental_score']:<6.1f} "
                  f"{pe_str:<8} {roe_str:<8} {stock.get('ai_recommendation', 'N/A'):<15} "
                  f"{stock.get('sector', 'Unknown')[:14]:<15}")
    else:
        print("âŒ æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„è‚¡ç¥¨")
        if not relaxed:
            print("ğŸ’¡ å»ºè®®: å°è¯•ä½¿ç”¨å®½æ¾æ¡ä»¶ quick_screen_enhanced('value', relaxed=True)")

    return results

def test_screening():
    """æµ‹è¯•ç­›é€‰åŠŸèƒ½"""
    print("ğŸ§ª æµ‹è¯•ç­›é€‰åŠŸèƒ½...")

    quantgpt = QuantGPT()

    # æµ‹è¯•å°‘é‡è‚¡ç¥¨
    test_symbols = ["AAPL", "JNJ", "KO", "PG", "WMT"]

    print("\n1. æµ‹è¯•æ ‡å‡†ä»·å€¼è‚¡ç­›é€‰...")
    results1 = quantgpt.screen_stocks_basic(ScreeningPresets.value_stocks(), test_symbols)
    print(f"æ ‡å‡†æ¡ä»¶ç»“æœ: {len(results1)} åª")

    print("\n2. æµ‹è¯•å®½æ¾ä»·å€¼è‚¡ç­›é€‰...")
    results2 = quantgpt.screen_stocks_basic(ScreeningPresets.relaxed_value_stocks(), test_symbols)
    print(f"å®½æ¾æ¡ä»¶ç»“æœ: {len(results2)} åª")

    return results1, results2

def interactive_session(quantgpt=None):
    """äº¤äº’å¼ä¼šè¯"""
    if quantgpt is None:
        quantgpt = QuantGPT()

    print("ğŸ¯ æ¬¢è¿ä½¿ç”¨QuantGPTäº¤äº’ç³»ç»Ÿ!")
    print("è¾“å…¥ 'help' æŸ¥çœ‹å¯ç”¨å‘½ä»¤")

    while True:
        try:
            command = input("\nQuantGPT> ").strip().lower()

            if command == "quit" or command == "exit":
                print("ğŸ‘‹ å†è§!")
                break

            elif command == "help":
                print("\nğŸ“– å¯ç”¨å‘½ä»¤:")
                print("analyze <è‚¡ç¥¨ä»£ç >     - AIè‚¡ç¥¨åˆ†æ")
                print("fundamental <è‚¡ç¥¨ä»£ç > - åŸºæœ¬é¢åˆ†æ")
                print("sentiment <æ–‡æœ¬>      - æƒ…æ„Ÿåˆ†æ")
                print("backtest <è‚¡ç¥¨> <ç­–ç•¥> - ç­–ç•¥å›æµ‹")
                print("compare <è‚¡ç¥¨>         - ç­–ç•¥æ¯”è¾ƒ")
                print("screen <ç±»å‹>         - è‚¡ç¥¨ç­›é€‰ (value/growth/quality)")
                print("help                  - æ˜¾ç¤ºå¸®åŠ©")
                print("quit                  - é€€å‡º")

            elif command.startswith("analyze "):
                symbol = command.split()[1].upper()
                result = quick_analyze(symbol, quantgpt)

            elif command.startswith("fundamental "):
                symbol = command.split()[1].upper()
                print(f"ğŸ“ˆ è·å– {symbol} åŸºæœ¬é¢æ•°æ®...")
                result = quantgpt.get_fundamental_data(symbol)
                if "error" not in result:
                    print(f"âœ… {symbol} åŸºæœ¬é¢åˆ†æ:")
                    print(f"   å…¬å¸: {result.get('company_name', 'N/A')}")
                    print(f"   è¡Œä¸š: {result.get('sector', 'N/A')}")
                    print(f"   PE: {result.get('pe_ratio', 'N/A')}")
                    print(f"   ROE: {(result.get('roe', 0) or 0) * 100:.1f}%")
                    print(f"   è¯„åˆ†: {result.get('fundamental_score', 0):.1f}/100")
                else:
                    print(f"âŒ {result['error']}")

            elif command.startswith("sentiment "):
                text = command[10:]
                print("ğŸ§  åˆ†ææƒ…æ„Ÿ...")
                result = quantgpt.ai_engine.analyze_sentiment(text)
                print(f"âœ… æƒ…æ„Ÿåˆ†æç»“æœ:")
                print(f"   æ–‡æœ¬: {text}")
                print(f"   æƒ…æ„Ÿ: {result['sentiment']}")
                print(f"   ç½®ä¿¡åº¦: {result['confidence']:.2%}")

            elif command.startswith("backtest "):
                parts = command.split()
                if len(parts) >= 3:
                    symbol = parts[1].upper()
                    strategy = parts[2]
                    print(f"ğŸ”¬ å›æµ‹ {symbol} - {strategy}...")
                    result = quantgpt.run_strategy_backtest(symbol, strategy)
                    if "error" not in result:
                        metrics = result["metrics"]
                        print(f"âœ… å›æµ‹ç»“æœ:")
                        print(f"   æ€»æ”¶ç›Šç‡: {metrics.get('total_return', 0):.2%}")
                        print(f"   å¤æ™®æ¯”ç‡: {metrics.get('sharpe_ratio', 0):.3f}")
                        print(f"   æœ€å¤§å›æ’¤: {metrics.get('max_drawdown', 0):.2%}")
                    else:
                        print(f"âŒ {result['error']}")
                else:
                    print("âŒ ç”¨æ³•: backtest <è‚¡ç¥¨ä»£ç > <ç­–ç•¥å>")

            elif command.startswith("compare "):
                symbol = command.split()[1].upper()
                strategies = ["sma_crossover", "rsi", "bollinger_bands", "ai_sentiment"]
                print(f"ğŸ“ˆ æ¯”è¾ƒ {symbol} çš„æ‰€æœ‰ç­–ç•¥...")
                result = quantgpt.compare_strategies(symbol, strategies)
                if "error" not in result:
                    print(f"âœ… æœ€ä½³ç­–ç•¥: {result['best_strategy']}")
                    for strategy, data in result["strategies"].items():
                        metrics = data["metrics"]
                        print(f"   {strategy}: {metrics.get('total_return', 0):.2%}")
                else:
                    print(f"âŒ {result['error']}")

            elif command.startswith("screen "):
                screen_type = command.split()[1] if len(command.split()) > 1 else "value"
                quick_screen(screen_type, quantgpt)

            else:
                print("âŒ æ— æ•ˆå‘½ä»¤ï¼Œè¾“å…¥ 'help' æŸ¥çœ‹å¸®åŠ©")

        except KeyboardInterrupt:
            print("\nğŸ‘‹ ç”¨æˆ·ä¸­æ–­æ“ä½œ")
            break
        except Exception as e:
            print(f"âŒ é”™è¯¯: {e}")

# =====================================================
# ä¸»å‡½æ•°
# =====================================================

def main():
    """ä¸»å‡½æ•°"""
    print("ğŸ¯ QuantGPTå¯åŠ¨é€‰é¡¹:")
    print("1. å¿«é€Ÿå¯åŠ¨")
    print("2. äº¤äº’æ¨¡å¼")
    print("3. è‡ªå®šä¹‰åˆ†æ")

    try:
        choice = input("\nè¯·é€‰æ‹© (1-3): ").strip()

        if choice == "1":
            quantgpt = quick_start()
            return quantgpt

        elif choice == "2":
            quantgpt = QuantGPT()
            interactive_session(quantgpt)
            return quantgpt

        elif choice == "3":
            print("ğŸ”§ è‡ªå®šä¹‰åˆ†ææ¨¡å¼...")
            quantgpt = QuantGPT()

            while True:
                print("\nğŸ¯ è‡ªå®šä¹‰åˆ†æ:")
                print("- analyze <è‚¡ç¥¨ä»£ç >: å®Œæ•´åˆ†æ")
                print("- screen <ç±»å‹>: è‚¡ç¥¨ç­›é€‰")
                print("- backtest <è‚¡ç¥¨> <ç­–ç•¥>: å›æµ‹")
                print("- interactive: è¿›å…¥äº¤äº’æ¨¡å¼")
                print("- quit: é€€å‡º")

                cmd = input("\nè‡ªå®šä¹‰> ").strip().split()

                if not cmd:
                    continue
                elif cmd[0] == "quit":
                    break
                elif cmd[0] == "interactive":
                    interactive_session(quantgpt)
                    break
                elif cmd[0] == "analyze" and len(cmd) > 1:
                    quick_analyze(cmd[1], quantgpt)
                elif cmd[0] == "screen" and len(cmd) > 1:
                    quick_screen(cmd[1], quantgpt)
                elif cmd[0] == "backtest" and len(cmd) > 2:
                    result = quantgpt.run_strategy_backtest(cmd[1], cmd[2])
                    if "error" not in result:
                        metrics = result["metrics"]
                        print(f"âœ… å›æµ‹ç»“æœ: {metrics.get('total_return', 0):.2%}")
                    else:
                        print(f"âŒ {result['error']}")
                else:
                    print("âŒ æ— æ•ˆå‘½ä»¤")

            return quantgpt
        else:
            print("âŒ æ— æ•ˆé€‰æ‹©")
            return None

    except KeyboardInterrupt:
        print("\nğŸ‘‹ ç”¨æˆ·å–æ¶ˆæ“ä½œ")
        return None

if __name__ == "__main__":
    app = main()
else:
    print("ğŸ‰ QuantGPTç³»ç»Ÿå·²å¯¼å…¥!")
    print("ğŸš€ ä½¿ç”¨ quick_start() å¿«é€Ÿå¼€å§‹")
    print("ğŸ¯ ä½¿ç”¨ interactive_session() è¿›å…¥äº¤äº’æ¨¡å¼")
    print("ğŸ“Š ä½¿ç”¨ quick_analyze('AAPL') å¿«é€Ÿåˆ†æ")
    print("ğŸ” ä½¿ç”¨ quick_screen('value') å¿«é€Ÿç­›é€‰")
    print("ğŸ§ª ä½¿ç”¨ test_screening() æµ‹è¯•ç­›é€‰åŠŸèƒ½")
    print("ğŸ’¡ ä½¿ç”¨ quick_screen_enhanced('value', relaxed=True) å®½æ¾ç­›é€‰")

print("\nâœ¨ QuantGPTå®Œæ•´ç³»ç»ŸåŠ è½½å®Œæˆï¼")